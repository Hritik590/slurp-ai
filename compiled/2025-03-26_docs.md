# Compiled Documentation

Generated on 2025-04-02T22:53:10.038Z

### 2025-03-26

#### _specification_2025-03-26.md

> Source: https://spec.modelcontextprotocol.io/specification/2025-03-26
> Scraped: 4/2/2025, 4:52:10 PM

**Protocol Revision**: 2025-03-26

[Model Context Protocol](https://modelcontextprotocol.io/) (MCP) is an open protocol that enables seamless integration between LLM applications and external data sources and tools. Whether you’re building an AI-powered IDE, enhancing a chat interface, or creating custom AI workflows, MCP provides a standardized way to connect LLMs with the context they need.

This specification defines the authoritative protocol requirements, based on the TypeScript schema in [schema.ts](https://github.com/modelcontextprotocol/specification/blob/main/schema/2025-03-26/schema.ts).

For implementation guides and examples, visit [modelcontextprotocol.io](https://modelcontextprotocol.io/).

The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “NOT RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in [BCP 14](https://datatracker.ietf.org/doc/html/bcp14) \[[RFC2119](https://datatracker.ietf.org/doc/html/rfc2119)\] \[[RFC8174](https://datatracker.ietf.org/doc/html/rfc8174)\] when, and only when, they appear in all capitals, as shown here.

## Overview[](_specification_2025-03-26.md#overview)

MCP provides a standardized way for applications to:
*   Share contextual information with language models
*   Expose tools and capabilities to AI systems
*   Build composable integrations and workflows

The protocol uses [JSON-RPC](https://www.jsonrpc.org/) 2.0 messages to establish communication between:
*   **Hosts**: LLM applications that initiate connections
*   **Clients**: Connectors within the host application
*   **Servers**: Services that provide context and capabilities

MCP takes some inspiration from the [Language Server Protocol](https://microsoft.github.io/language-server-protocol/), which standardizes how to add support for programming languages across a whole ecosystem of development tools. In a similar way, MCP standardizes how to integrate additional context and tools into the ecosystem of AI applications.

## Key Details[](_specification_2025-03-26.md#key-details)

### Base Protocol[](_specification_2025-03-26.md#base-protocol)
*   [JSON-RPC](https://www.jsonrpc.org/) message format
*   Stateful connections
*   Server and client capability negotiation

### Features[](_specification_2025-03-26.md#features)

Servers offer any of the following features to clients:
*   **Resources**: Context and data, for the user or the AI model to use
*   **Prompts**: Templated messages and workflows for users
*   **Tools**: Functions for the AI model to execute

Clients may offer the following feature to servers:
*   **Sampling**: Server-initiated agentic behaviors and recursive LLM interactions

### Additional Utilities[](_specification_2025-03-26.md#additional-utilities)
*   Configuration
*   Progress tracking
*   Cancellation
*   Error reporting
*   Logging

## Security and Trust & Safety[](_specification_2025-03-26.md#security-and-trust--safety)

The Model Context Protocol enables powerful capabilities through arbitrary data access and code execution paths. With this power comes important security and trust considerations that all implementors must carefully address.

### Key Principles[](_specification_2025-03-26.md#key-principles)

1.  **User Consent and Control**   Users must explicitly consent to and understand all data access and operations
    *   Users must retain control over what data is shared and what actions are taken
    *   Implementors should provide clear UIs for reviewing and authorizing activities
2.  **Data Privacy**   Hosts must obtain explicit user consent before exposing user data to servers
    *   Hosts must not transmit resource data elsewhere without user consent
    *   User data should be protected with appropriate access controls
3.  **Tool Safety**   Tools represent arbitrary code execution and must be treated with appropriate caution.
        *   In particular, descriptions of tool behavior such as annotations should be considered untrusted, unless obtained from a trusted server.
    *   Hosts must obtain explicit user consent before invoking any tool
    *   Users should understand what each tool does before authorizing its use
4.  **LLM Sampling Controls**   Users must explicitly approve any LLM sampling requests
    *   Users should control:
        *   Whether sampling occurs at all
        *   The actual prompt that will be sent
        *   What results the server can see
    *   The protocol intentionally limits server visibility into prompts

### Implementation Guidelines[](_specification_2025-03-26.md#implementation-guidelines)

While MCP itself cannot enforce these security principles at the protocol level, implementors **SHOULD**:

1.  Build robust consent and authorization flows into their applications
2.  Provide clear documentation of security implications
3.  Implement appropriate access controls and data protections
4.  Follow security best practices in their integrations
5.  Consider privacy implications in their feature designs

## Learn More[](_specification_2025-03-26.md#learn-more)

Explore the detailed specification for each protocol component:

#### _specification_2025-03-26_architecture.md

> Source: https://spec.modelcontextprotocol.io/specification/2025-03-26/architecture
> Scraped: 4/2/2025, 4:52:13 PM

The Model Context Protocol (MCP) follows a client-host-server architecture where each host can run multiple client instances. This architecture enables users to integrate AI capabilities across applications while maintaining clear security boundaries and isolating concerns. Built on JSON-RPC, MCP provides a stateful session protocol focused on context exchange and sampling coordination between clients and servers.

## Core Components[](_specification_2025-03-26_architecture.md#core-components)
```
graph LR
    subgraph "Application Host Process"
        H\[Host\]
        C1\[Client 1\]
        C2\[Client 2\]
        C3\[Client 3\]
        H --> C1
        H --> C2
        H --> C3
    end
    subgraph "Local machine"
        S1\[Server 1  
Files & Git\]
        S2\[Server 2  
Database\]
        R1\[("Local  
Resource A")\]
        R2\[("Local  
Resource B")\]
        C1 --> S1
        C2 --> S2
        S1 <--> R1
        S2 <--> R2
    end
    subgraph "Internet"
        S3\[Server 3  
External APIs\]
        R3\[("Remote  
Resource C")\]
        C3 --> S3
        S3 <--> R3
    end
```
### Host[](_specification_2025-03-26_architecture.md#host)

The host process acts as the container and coordinator:
*   Creates and manages multiple client instances
*   Controls client connection permissions and lifecycle
*   Enforces security policies and consent requirements
*   Handles user authorization decisions
*   Coordinates AI/LLM integration and sampling
*   Manages context aggregation across clients

### Clients[](_specification_2025-03-26_architecture.md#clients)

Each client is created by the host and maintains an isolated server connection:
*   Establishes one stateful session per server
*   Handles protocol negotiation and capability exchange
*   Routes protocol messages bidirectionally
*   Manages subscriptions and notifications
*   Maintains security boundaries between servers

A host application creates and manages multiple clients, with each client having a 1:1 relationship with a particular server.

### Servers[](_specification_2025-03-26_architecture.md#servers)

Servers provide specialized context and capabilities:
*   Expose resources, tools and prompts via MCP primitives
*   Operate independently with focused responsibilities
*   Request sampling through client interfaces
*   Must respect security constraints
*   Can be local processes or remote services

## Design Principles[](_specification_2025-03-26_architecture.md#design-principles)

MCP is built on several key design principles that inform its architecture and implementation:

1.  **Servers should be extremely easy to build**   Host applications handle complex orchestration responsibilities
    *   Servers focus on specific, well-defined capabilities
    *   Simple interfaces minimize implementation overhead
    *   Clear separation enables maintainable code
2.  **Servers should be highly composable**   Each server provides focused functionality in isolation
    *   Multiple servers can be combined seamlessly
    *   Shared protocol enables interoperability
    *   Modular design supports extensibility
3.  **Servers should not be able to read the whole conversation, nor “see into” other servers**   Servers receive only necessary contextual information
    *   Full conversation history stays with the host
    *   Each server connection maintains isolation
    *   Cross-server interactions are controlled by the host
    *   Host process enforces security boundaries
4.  **Features can be added to servers and clients progressively**   Core protocol provides minimal required functionality
    *   Additional capabilities can be negotiated as needed
    *   Servers and clients evolve independently
    *   Protocol designed for future extensibility
    *   Backwards compatibility is maintained

## Capability Negotiation[](_specification_2025-03-26_architecture.md#capability-negotiation)

The Model Context Protocol uses a capability-based negotiation system where clients and servers explicitly declare their supported features during initialization. Capabilities determine which protocol features and primitives are available during a session.
*   Servers declare capabilities like resource subscriptions, tool support, and prompt templates
*   Clients declare capabilities like sampling support and notification handling
*   Both parties must respect declared capabilities throughout the session
*   Additional capabilities can be negotiated through extensions to the protocol
```
sequenceDiagram
    participant Host
    participant Client
    participant Server
    Host->>+Client: Initialize client
    Client->>+Server: Initialize session with capabilities
    Server-->>Client: Respond with supported capabilities
    Note over Host,Server: Active Session with Negotiated Features
    loop Client Requests
        Host->>Client: User- or model-initiated action
        Client->>Server: Request (tools/resources)
        Server-->>Client: Response
        Client-->>Host: Update UI or respond to model
    end
    loop Server Requests
        Server->>Client: Request (sampling)
        Client->>Host: Forward to AI
        Host-->>Client: AI response
        Client-->>Server: Response
    end
    loop Notifications
        Server--)Client: Resource updates
        Client--)Server: Status changes
    end
    Host->>Client: Terminate
    Client->>-Server: End session
    deactivate Server
```
Each capability unlocks specific protocol features for use during the session. For example:
*   Implemented [server features](_specification_2025-03-26_server_.md) must be advertised in the server’s capabilities
*   Emitting resource subscription notifications requires the server to declare subscription support
*   Tool invocation requires the server to declare tool capabilities
*   [Sampling](_specification_2025-03-26_client_.md) requires the client to declare support in its capabilities

This capability negotiation ensures clients and servers have a clear understanding of supported functionality while maintaining protocol extensibility.

#### _specification_2025-03-26_basic.md

> Source: https://spec.modelcontextprotocol.io/specification/2025-03-26/basic
> Scraped: 4/2/2025, 4:52:13 PM

**Protocol Revision**: 2025-03-26

The Model Context Protocol consists of several key components that work together:
*   **Base Protocol**: Core JSON-RPC message types
*   **Lifecycle Management**: Connection initialization, capability negotiation, and session control
*   **Server Features**: Resources, prompts, and tools exposed by servers
*   **Client Features**: Sampling and root directory lists provided by clients
*   **Utilities**: Cross-cutting concerns like logging and argument completion

All implementations **MUST** support the base protocol and lifecycle management components. Other components **MAY** be implemented based on the specific needs of the application.

These protocol layers establish clear separation of concerns while enabling rich interactions between clients and servers. The modular design allows implementations to support exactly the features they need.

## Messages[](_specification_2025-03-26_basic.md#messages)

All messages between MCP clients and servers **MUST** follow the [JSON-RPC 2.0](https://www.jsonrpc.org/specification) specification. The protocol defines these types of messages:

### Requests[](_specification_2025-03-26_basic.md#requests)

Requests are sent from the client to the server or vice versa, to initiate an operation.
*   Requests **MUST** include a string or integer ID.
*   Unlike base JSON-RPC, the ID **MUST NOT** be `null`.
*   The request ID **MUST NOT** have been previously used by the requestor within the same session.

### Responses[](_specification_2025-03-26_basic.md#responses)

Responses are sent in reply to requests, containing the result or error of the operation.
*   Responses **MUST** include the same ID as the request they correspond to.
*   **Responses** are further sub-categorized as either **successful results** or **errors**. Either a `result` or an `error` **MUST** be set. A response **MUST NOT** set both.
*   Results **MAY** follow any JSON object structure, while errors **MUST** include an error code and message at minimum.
*   Error codes **MUST** be integers.

### Notifications[](_specification_2025-03-26_basic.md#notifications)

Notifications are sent from the client to the server or vice versa, as a one-way message. The receiver **MUST NOT** send a response.
*   Notifications **MUST NOT** include an ID.

### Batching[](_specification_2025-03-26_basic.md#batching)

JSON-RPC also defines a means to [batch multiple requests and notifications](https://www.jsonrpc.org/specification#batch), by sending them in an array. MCP implementations **MAY** support sending JSON-RPC batches, but **MUST** support receiving JSON-RPC batches.

## Auth[](_specification_2025-03-26_basic.md#auth)

MCP provides an [Authorization](_specification_2025-03-26_basic_authorization_.md) framework for use with HTTP. Implementations using an HTTP-based transport **SHOULD** conform to this specification, whereas implementations using STDIO transport **SHOULD NOT** follow this specification, and instead retrieve credentials from the environment.

Additionally, clients and servers **MAY** negotiate their own custom authentication and authorization strategies.

For further discussions and contributions to the evolution of MCP’s auth mechanisms, join us in [GitHub Discussions](https://github.com/modelcontextprotocol/specification/discussions) to help shape the future of the protocol!

## Schema[](_specification_2025-03-26_basic.md#schema)

The full specification of the protocol is defined as a [TypeScript schema](https://github.com/modelcontextprotocol/specification/blob/main/schema/2025-03-26/schema.ts). This is the source of truth for all protocol messages and structures.

There is also a [JSON Schema](https://github.com/modelcontextprotocol/specification/blob/main/schema/2025-03-26/schema.json), which is automatically generated from the TypeScript source of truth, for use with various automated tooling.

#### _specification_2025-03-26_basic_authorization.md

> Source: https://spec.modelcontextprotocol.io/specification/2025-03-26/basic/authorization
> Scraped: 4/2/2025, 4:52:13 PM

**Protocol Revision**: 2025-03-26

## 1\. Introduction[](_specification_2025-03-26_basic_authorization.md#1-introduction)

### 1.1 Purpose and Scope[](_specification_2025-03-26_basic_authorization.md#11-purpose-and-scope)

The Model Context Protocol provides authorization capabilities at the transport level, enabling MCP clients to make requests to restricted MCP servers on behalf of resource owners. This specification defines the authorization flow for HTTP-based transports.

### 1.2 Protocol Requirements[](_specification_2025-03-26_basic_authorization.md#12-protocol-requirements)

Authorization is **OPTIONAL** for MCP implementations. When supported:
*   Implementations using an HTTP-based transport **SHOULD** conform to this specification.
*   Implementations using an STDIO transport **SHOULD NOT** follow this specification, and instead retrieve credentials from the environment.
*   Implementations using alternative transports **MUST** follow established security best practices for their protocol.

### 1.3 Standards Compliance[](_specification_2025-03-26_basic_authorization.md#13-standards-compliance)

This authorization mechanism is based on established specifications listed below, but implements a selected subset of their features to ensure security and interoperability while maintaining simplicity:
*   [OAuth 2.1 IETF DRAFT](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-12)
*   OAuth 2.0 Authorization Server Metadata ([RFC8414](https://datatracker.ietf.org/doc/html/rfc8414))
*   OAuth 2.0 Dynamic Client Registration Protocol ([RFC7591](https://datatracker.ietf.org/doc/html/rfc7591))

## 2\. Authorization Flow[](_specification_2025-03-26_basic_authorization.md#2-authorization-flow)

### 2.1 Overview[](_specification_2025-03-26_basic_authorization.md#21-overview)

1.  MCP auth implementations **MUST** implement OAuth 2.1 with appropriate security measures for both confidential and public clients.
    
2.  MCP auth implementations **SHOULD** support the OAuth 2.0 Dynamic Client Registration Protocol ([RFC7591](https://datatracker.ietf.org/doc/html/rfc7591)).
    
3.  MCP servers **SHOULD** and MCP clients **MUST** implement OAuth 2.0 Authorization Server Metadata ([RFC8414](https://datatracker.ietf.org/doc/html/rfc8414)). Servers that do not support Authorization Server Metadata **MUST** follow the default URI schema.
    

### 2.2 Basic OAuth 2.1 Authorization[](_specification_2025-03-26_basic_authorization.md#22-basic-oauth-21-authorization)

When authorization is required and not yet proven by the client, servers **MUST** respond with _HTTP 401 Unauthorized_.

Clients initiate the [OAuth 2.1 IETF DRAFT](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-12) authorization flow after receiving the _HTTP 401 Unauthorized_.

The following demonstrates the basic OAuth 2.1 for public clients using PKCE.
```
sequenceDiagram
    participant B as User-Agent (Browser)
    participant C as Client
    participant M as MCP Server
    C->>M: MCP Request
    M->>C: HTTP 401 Unauthorized
    Note over C: Generate code\_verifier and code\_challenge
    C->>B: Open browser with authorization URL + code\_challenge
    B->>M: GET /authorize
    Note over M: User logs in and authorizes
    M->>B: Redirect to callback URL with auth code
    B->>C: Callback with authorization code
    C->>M: Token Request with code + code\_verifier
    M->>C: Access Token (+ Refresh Token)
    C->>M: MCP Request with Access Token
    Note over C,M: Begin standard MCP message exchange
```
### 2.3 Server Metadata Discovery[](_specification_2025-03-26_basic_authorization.md#23-server-metadata-discovery)

For server capability discovery:
*   MCP clients _MUST_ follow the OAuth 2.0 Authorization Server Metadata protocol defined in [RFC8414](https://datatracker.ietf.org/doc/html/rfc8414).
*   MCP server _SHOULD_ follow the OAuth 2.0 Authorization Server Metadata protocol.
*   MCP servers that do not support the OAuth 2.0 Authorization Server Metadata protocol, _MUST_ support fallback URLs.

The discovery flow is illustrated below:
```
sequenceDiagram
    participant C as Client
    participant S as Server
    C->>S: GET /.well-known/oauth-authorization-server
    alt Discovery Success
        S->>C: 200 OK + Metadata Document
        Note over C: Use endpoints from metadata
    else Discovery Failed
        S->>C: 404 Not Found
        Note over C: Fall back to default endpoints
    end
    Note over C: Continue with authorization flow
```
#### 2.3.1 Server Metadata Discovery Headers[](_specification_2025-03-26_basic_authorization.md#231-server-metadata-discovery-headers)

MCP clients _SHOULD_ include the header `MCP-Protocol-Version: <protocol-version>` during Server Metadata Discovery to allow the MCP server to respond based on the MCP protocol version.

For example: `MCP-Protocol-Version: 2024-11-05`

#### 2.3.2 Authorization Base URL[](_specification_2025-03-26_basic_authorization.md#232-authorization-base-url)

The authorization base URL **MUST** be determined from the MCP server URL by discarding any existing `path` component. For example:

If the MCP server URL is `https://api.example.com/v1/mcp`, then:
*   The authorization base URL is `https://api.example.com`
*   The metadata endpoint **MUST** be at `https://api.example.com/.well-known/oauth-authorization-server`

This ensures authorization endpoints are consistently located at the root level of the domain hosting the MCP server, regardless of any path components in the MCP server URL.

#### 2.3.3 Fallbacks for Servers without Metadata Discovery[](_specification_2025-03-26_basic_authorization.md#233-fallbacks-for-servers-without-metadata-discovery)

For servers that do not implement OAuth 2.0 Authorization Server Metadata, clients **MUST** use the following default endpoint paths relative to the authorization base URL (as defined in [Section 2.3.2](_specification_2025-03-26_basic_authorization.md#232-authorization-base-url)):

Endpoint

Default Path

Description

Authorization Endpoint

/authorize

Used for authorization requests

Token Endpoint

/token

Used for token exchange & refresh

Registration Endpoint

/register

Used for dynamic client registration

For example, with an MCP server hosted at `https://api.example.com/v1/mcp`, the default endpoints would be:
*   `https://api.example.com/authorize`
*   `https://api.example.com/token`
*   `https://api.example.com/register`

Clients **MUST** first attempt to discover endpoints via the metadata document before falling back to default paths. When using default paths, all other protocol requirements remain unchanged.

### 2.3 Dynamic Client Registration[](_specification_2025-03-26_basic_authorization.md#23-dynamic-client-registration)

MCP clients and servers **SHOULD** support the [OAuth 2.0 Dynamic Client Registration Protocol](https://datatracker.ietf.org/doc/html/rfc7591) to allow MCP clients to obtain OAuth client IDs without user interaction. This provides a standardized way for clients to automatically register with new servers, which is crucial for MCP because:
*   Clients cannot know all possible servers in advance
*   Manual registration would create friction for users
*   It enables seamless connection to new servers
*   Servers can implement their own registration policies

Any MCP servers that _do not_ support Dynamic Client Registration need to provide alternative ways to obtain a client ID (and, if applicable, client secret). For one of these servers, MCP clients will have to either:

1.  Hardcode a client ID (and, if applicable, client secret) specifically for that MCP server, or
2.  Present a UI to users that allows them to enter these details, after registering an OAuth client themselves (e.g., through a configuration interface hosted by the server).

### 2.4 Authorization Flow Steps[](_specification_2025-03-26_basic_authorization.md#24-authorization-flow-steps)

The complete Authorization flow proceeds as follows:
```
sequenceDiagram
    participant B as User-Agent (Browser)
    participant C as Client
    participant M as MCP Server
    C->>M: GET /.well-known/oauth-authorization-server
    alt Server Supports Discovery
        M->>C: Authorization Server Metadata
    else No Discovery
        M->>C: 404 (Use default endpoints)
    end
    alt Dynamic Client Registration
        C->>M: POST /register
        M->>C: Client Credentials
    end
    Note over C: Generate PKCE Parameters
    C->>B: Open browser with authorization URL + code\_challenge
    B->>M: Authorization Request
    Note over M: User /authorizes
    M->>B: Redirect to callback with authorization code
    B->>C: Authorization code callback
    C->>M: Token Request + code\_verifier
    M->>C: Access Token (+ Refresh Token)
    C->>M: API Requests with Access Token
```
#### 2.4.1 Decision Flow Overview[](_specification_2025-03-26_basic_authorization.md#241-decision-flow-overview)
```
flowchart TD
    A\[Start Auth Flow\] --> B{Check Metadata Discovery}
    B -->|Available| C\[Use Metadata Endpoints\]
    B -->|Not Available| D\[Use Default Endpoints\]
    C --> G{Check Registration Endpoint}
    D --> G
    G -->|Available| H\[Perform Dynamic Registration\]
    G -->|Not Available| I\[Alternative Registration Required\]
    H --> J\[Start OAuth Flow\]
    I --> J
    J --> K\[Generate PKCE Parameters\]
    K --> L\[Request Authorization\]
    L --> M\[User Authorization\]
    M --> N\[Exchange Code for Tokens\]
    N --> O\[Use Access Token\]
```
### 2.5 Access Token Usage[](_specification_2025-03-26_basic_authorization.md#25-access-token-usage)

#### 2.5.1 Token Requirements[](_specification_2025-03-26_basic_authorization.md#251-token-requirements)

Access token handling **MUST** conform to [OAuth 2.1 Section 5](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-12#section-5) requirements for resource requests. Specifically:

1.  MCP client **MUST** use the Authorization request header field [Section 5.1.1](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-12#section-5.1.1):

Note that authorization **MUST** be included in every HTTP request from client to server, even if they are part of the same logical session.

1.  Access tokens **MUST NOT** be included in the URI query string

Example request:

#### 2.5.2 Token Handling[](_specification_2025-03-26_basic_authorization.md#252-token-handling)

Resource servers **MUST** validate access tokens as described in [Section 5.2](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-12#section-5.2). If validation fails, servers **MUST** respond according to [Section 5.3](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-12#section-5.3) error handling requirements. Invalid or expired tokens **MUST** receive a HTTP 401 response.

### 2.6 Security Considerations[](_specification_2025-03-26_basic_authorization.md#26-security-considerations)

The following security requirements **MUST** be implemented:

1.  Clients **MUST** securely store tokens following OAuth 2.0 best practices
2.  Servers **SHOULD** enforce token expiration and rotation
3.  All authorization endpoints **MUST** be served over HTTPS
4.  Servers **MUST** validate redirect URIs to prevent open redirect vulnerabilities
5.  Redirect URIs **MUST** be either localhost URLs or HTTPS URLs

### 2.7 Error Handling[](_specification_2025-03-26_basic_authorization.md#27-error-handling)

Servers **MUST** return appropriate HTTP status codes for authorization errors:

Status Code

Description

Usage

401

Unauthorized

Authorization required or token invalid

403

Forbidden

Invalid scopes or insufficient permissions

400

Bad Request

Malformed authorization request

### 2.8 Implementation Requirements[](_specification_2025-03-26_basic_authorization.md#28-implementation-requirements)

1.  Implementations **MUST** follow OAuth 2.1 security best practices
2.  PKCE is **REQUIRED** for all clients
3.  Token rotation **SHOULD** be implemented for enhanced security
4.  Token lifetimes **SHOULD** be limited based on security requirements

### 2.9 Third-Party Authorization Flow[](_specification_2025-03-26_basic_authorization.md#29-third-party-authorization-flow)

#### 2.9.1 Overview[](_specification_2025-03-26_basic_authorization.md#291-overview)

MCP servers **MAY** support delegated authorization through third-party authorization servers. In this flow, the MCP server acts as both an OAuth client (to the third-party auth server) and an OAuth authorization server (to the MCP client).

#### 2.9.2 Flow Description[](_specification_2025-03-26_basic_authorization.md#292-flow-description)

The third-party authorization flow comprises these steps:

1.  MCP client initiates standard OAuth flow with MCP server
2.  MCP server redirects user to third-party authorization server
3.  User authorizes with third-party server
4.  Third-party server redirects back to MCP server with authorization code
5.  MCP server exchanges code for third-party access token
6.  MCP server generates its own access token bound to the third-party session
7.  MCP server completes original OAuth flow with MCP client
```
sequenceDiagram
    participant B as User-Agent (Browser)
    participant C as MCP Client
    participant M as MCP Server
    participant T as Third-Party Auth Server
    C->>M: Initial OAuth Request
    M->>B: Redirect to Third-Party /authorize
    B->>T: Authorization Request
    Note over T: User authorizes
    T->>B: Redirect to MCP Server callback
    B->>M: Authorization code
    M->>T: Exchange code for token
    T->>M: Third-party access token
    Note over M: Generate bound MCP token
    M->>B: Redirect to MCP Client callback
    B->>C: MCP authorization code
    C->>M: Exchange code for token
    M->>C: MCP access token
```
#### 2.9.3 Session Binding Requirements[](_specification_2025-03-26_basic_authorization.md#293-session-binding-requirements)

MCP servers implementing third-party authorization **MUST**:

1.  Maintain secure mapping between third-party tokens and issued MCP tokens
2.  Validate third-party token status before honoring MCP tokens
3.  Implement appropriate token lifecycle management
4.  Handle third-party token expiration and renewal

#### 2.9.4 Security Considerations[](_specification_2025-03-26_basic_authorization.md#294-security-considerations)

When implementing third-party authorization, servers **MUST**:

1.  Validate all redirect URIs
2.  Securely store third-party credentials
3.  Implement appropriate session timeout handling
4.  Consider security implications of token chaining
5.  Implement proper error handling for third-party auth failures

## 3\. Best Practices[](_specification_2025-03-26_basic_authorization.md#3-best-practices)

#### 3.1 Local clients as Public OAuth 2.1 Clients[](_specification_2025-03-26_basic_authorization.md#31-local-clients-as-public-oauth-21-clients)

We strongly recommend that local clients implement OAuth 2.1 as a public client:

1.  Utilizing code challenges (PKCE) for authorization requests to prevent interception attacks
2.  Implementing secure token storage appropriate for the local system
3.  Following token refresh best practices to maintain sessions
4.  Properly handling token expiration and renewal

#### 3.2 Authorization Metadata Discovery[](_specification_2025-03-26_basic_authorization.md#32-authorization-metadata-discovery)

We strongly recommend that all clients implement metadata discovery. This reduces the need for users to provide endpoints manually or clients to fallback to the defined defaults.

#### 3.3 Dynamic Client Registration[](_specification_2025-03-26_basic_authorization.md#33-dynamic-client-registration)

Since clients do not know the set of MCP servers in advance, we strongly recommend the implementation of dynamic client registration. This allows applications to automatically register with the MCP server, and removes the need for users to obtain client ids manually.

#### _specification_2025-03-26_basic_lifecycle.md

> Source: https://spec.modelcontextprotocol.io/specification/2025-03-26/basic/lifecycle
> Scraped: 4/2/2025, 4:52:13 PM

**Protocol Revision**: 2025-03-26

The Model Context Protocol (MCP) defines a rigorous lifecycle for client-server connections that ensures proper capability negotiation and state management.

1.  **Initialization**: Capability negotiation and protocol version agreement
2.  **Operation**: Normal protocol communication
3.  **Shutdown**: Graceful termination of the connection
```
sequenceDiagram
    participant Client
    participant Server
    Note over Client,Server: Initialization Phase
    activate Client
    Client->>+Server: initialize request
    Server-->>Client: initialize response
    Client--)Server: initialized notification
    Note over Client,Server: Operation Phase
    rect rgb(200, 220, 250)
        note over Client,Server: Normal protocol operations
    end
    Note over Client,Server: Shutdown
    Client--)-Server: Disconnect
    deactivate Server
    Note over Client,Server: Connection closed
```
## Lifecycle Phases[](_specification_2025-03-26_basic_lifecycle.md#lifecycle-phases)

### Initialization[](_specification_2025-03-26_basic_lifecycle.md#initialization)

The initialization phase **MUST** be the first interaction between client and server. During this phase, the client and server:
*   Establish protocol version compatibility
*   Exchange and negotiate capabilities
*   Share implementation details

The client **MUST** initiate this phase by sending an `initialize` request containing:
*   Protocol version supported
*   Client capabilities
*   Client implementation information

The initialize request **MUST NOT** be part of a JSON-RPC [batch](https://www.jsonrpc.org/specification#batch), as other requests and notifications are not possible until initialization has completed. This also permits backwards compatibility with prior protocol versions that do not explicitly support JSON-RPC batches.

The server **MUST** respond with its own capabilities and information:

After successful initialization, the client **MUST** send an `initialized` notification to indicate it is ready to begin normal operations:
*   The client **SHOULD NOT** send requests other than [pings](_specification_2025-03-26_basic_utilities_ping_.md) before the server has responded to the `initialize` request.
*   The server **SHOULD NOT** send requests other than [pings](_specification_2025-03-26_basic_utilities_ping_.md) and [logging](_specification_2025-03-26_server_utilities_logging_.md) before receiving the `initialized` notification.

#### Version Negotiation[](_specification_2025-03-26_basic_lifecycle.md#version-negotiation)

In the `initialize` request, the client **MUST** send a protocol version it supports. This **SHOULD** be the _latest_ version supported by the client.

If the server supports the requested protocol version, it **MUST** respond with the same version. Otherwise, the server **MUST** respond with another protocol version it supports. This **SHOULD** be the _latest_ version supported by the server.

If the client does not support the version in the server’s response, it **SHOULD** disconnect.

#### Capability Negotiation[](_specification_2025-03-26_basic_lifecycle.md#capability-negotiation)

Client and server capabilities establish which optional protocol features will be available during the session.

Key capabilities include:

Category

Capability

Description

Client

`roots`

Ability to provide filesystem [roots](_specification_2025-03-26_client_roots_.md)

Client

`sampling`

Support for LLM [sampling](_specification_2025-03-26_client_sampling_.md) requests

Client

`experimental`

Describes support for non-standard experimental features

Server

`prompts`

Offers [prompt templates](_specification_2025-03-26_server_prompts_.md)

Server

`resources`

Provides readable [resources](_specification_2025-03-26_server_resources_.md)

Server

`tools`

Exposes callable [tools](_specification_2025-03-26_server_tools_.md)

Server

`logging`

Emits structured [log messages](_specification_2025-03-26_server_utilities_logging_.md)

Server

`experimental`

Describes support for non-standard experimental features

Capability objects can describe sub-capabilities like:
*   `listChanged`: Support for list change notifications (for prompts, resources, and tools)
*   `subscribe`: Support for subscribing to individual items’ changes (resources only)

### Operation[](_specification_2025-03-26_basic_lifecycle.md#operation)

During the operation phase, the client and server exchange messages according to the negotiated capabilities.

Both parties **SHOULD**:
*   Respect the negotiated protocol version
*   Only use capabilities that were successfully negotiated

### Shutdown[](_specification_2025-03-26_basic_lifecycle.md#shutdown)

During the shutdown phase, one side (usually the client) cleanly terminates the protocol connection. No specific shutdown messages are defined—instead, the underlying transport mechanism should be used to signal connection termination:

#### stdio[](_specification_2025-03-26_basic_lifecycle.md#stdio)

For the stdio [transport](_specification_2025-03-26_basic_transports_.md), the client **SHOULD** initiate shutdown by:

1.  First, closing the input stream to the child process (the server)
2.  Waiting for the server to exit, or sending `SIGTERM` if the server does not exit within a reasonable time
3.  Sending `SIGKILL` if the server does not exit within a reasonable time after `SIGTERM`

The server **MAY** initiate shutdown by closing its output stream to the client and exiting.

#### HTTP[](_specification_2025-03-26_basic_lifecycle.md#http)

For HTTP [transports](_specification_2025-03-26_basic_transports_.md), shutdown is indicated by closing the associated HTTP connection(s).

## Timeouts[](_specification_2025-03-26_basic_lifecycle.md#timeouts)

Implementations **SHOULD** establish timeouts for all sent requests, to prevent hung connections and resource exhaustion. When the request has not received a success or error response within the timeout period, the sender **SHOULD** issue a [cancellation notification](_specification_2025-03-26_basic_utilities_cancellation_.md) for that request and stop waiting for a response.

SDKs and other middleware **SHOULD** allow these timeouts to be configured on a per-request basis.

Implementations **MAY** choose to reset the timeout clock when receiving a [progress notification](_specification_2025-03-26_basic_utilities_progress_.md) corresponding to the request, as this implies that work is actually happening. However, implementations **SHOULD** always enforce a maximum timeout, regardless of progress notifications, to limit the impact of a misbehaving client or server.

## Error Handling[](_specification_2025-03-26_basic_lifecycle.md#error-handling)

Implementations **SHOULD** be prepared to handle these error cases:
*   Protocol version mismatch
*   Failure to negotiate required capabilities
*   Request [timeouts](_specification_2025-03-26_basic_lifecycle.md#timeouts)

Example initialization error:

#### _specification_2025-03-26_basic_transports.md

> Source: https://spec.modelcontextprotocol.io/specification/2025-03-26/basic/transports
> Scraped: 4/2/2025, 4:52:13 PM

**Protocol Revision**: 2025-03-26

MCP uses JSON-RPC to encode messages. JSON-RPC messages **MUST** be UTF-8 encoded.

The protocol currently defines two standard transport mechanisms for client-server communication:

1.  [stdio](_specification_2025-03-26_basic_transports.md#stdio), communication over standard in and standard out
2.  [Streamable HTTP](_specification_2025-03-26_basic_transports.md#streamable-http)

Clients **SHOULD** support stdio whenever possible.

It is also possible for clients and servers to implement [custom transports](_specification_2025-03-26_basic_transports.md#custom-transports) in a pluggable fashion.

## stdio[](_specification_2025-03-26_basic_transports.md#stdio)

In the **stdio** transport:
*   The client launches the MCP server as a subprocess.
*   The server reads JSON-RPC messages from its standard input (`stdin`) and sends messages to its standard output (`stdout`).
*   Messages may be JSON-RPC requests, notifications, responses—or a JSON-RPC [batch](https://www.jsonrpc.org/specification#batch) containing one or more requests and/or notifications.
*   Messages are delimited by newlines, and **MUST NOT** contain embedded newlines.
*   The server **MAY** write UTF-8 strings to its standard error (`stderr`) for logging purposes. Clients **MAY** capture, forward, or ignore this logging.
*   The server **MUST NOT** write anything to its `stdout` that is not a valid MCP message.
*   The client **MUST NOT** write anything to the server’s `stdin` that is not a valid MCP message.
```
sequenceDiagram
    participant Client
    participant Server Process
    Client->>+Server Process: Launch subprocess
    loop Message Exchange
        Client->>Server Process: Write to stdin
        Server Process->>Client: Write to stdout
        Server Process--)Client: Optional logs on stderr
    end
    Client->>Server Process: Close stdin, terminate subprocess
    deactivate Server Process
```
## Streamable HTTP[](_specification_2025-03-26_basic_transports.md#streamable-http)

In the **Streamable HTTP** transport, the server operates as an independent process that can handle multiple client connections. This transport uses HTTP POST and GET requests. Server can optionally make use of [Server-Sent Events](https://en.wikipedia.org/wiki/Server-sent_events) (SSE) to stream multiple server messages. This permits basic MCP servers, as well as more feature-rich servers supporting streaming and server-to-client notifications and requests.

The server **MUST** provide a single HTTP endpoint path (hereafter referred to as the **MCP endpoint**) that supports both POST and GET methods. For example, this could be a URL like `https://example.com/mcp`.

### Sending Messages to the Server[](_specification_2025-03-26_basic_transports.md#sending-messages-to-the-server)

Every JSON-RPC message sent from the client **MUST** be a new HTTP POST request to the MCP endpoint.

1.  The client **MUST** use HTTP POST to send JSON-RPC messages to the MCP endpoint.
2.  The client **MUST** include an `Accept` header, listing both `application/json` and `text/event-stream` as supported content types.
3.  The body of the POST request **MUST** be one of the following:
    *   A single JSON-RPC _request_, _notification_, or _response_
    *   An array [batching](https://www.jsonrpc.org/specification#batch) one or more _requests and/or notifications_
    *   An array [batching](https://www.jsonrpc.org/specification#batch) one or more _responses_
4.  If the input consists solely of (any number of) JSON-RPC _responses_ or _notifications_:
    *   If the server accepts the input, the server **MUST** return HTTP status code 202 Accepted with no body.
    *   If the server cannot accept the input, it **MUST** return an HTTP error status code (e.g., 400 Bad Request). The HTTP response body **MAY** comprise a JSON-RPC _error response_ that has no `id`.
5.  If the input contains any number of JSON-RPC _requests_, the server **MUST** either return `Content-Type: text/event-stream`, to initiate an SSE stream, or `Content-Type: application/json`, to return one JSON object. The client **MUST** support both these cases.
6.  If the server initiates an SSE stream:
    *   The SSE stream **SHOULD** eventually include one JSON-RPC _response_ per each JSON-RPC _request_ sent in the POST body. These _responses_ **MAY** be [batched](https://www.jsonrpc.org/specification#batch).
    *   The server **MAY** send JSON-RPC _requests_ and _notifications_ before sending a JSON-RPC _response_. These messages **SHOULD** relate to the originating client _request_. These _requests_ and _notifications_ **MAY** be [batched](https://www.jsonrpc.org/specification#batch).
    *   The server **SHOULD NOT** close the SSE stream before sending a JSON-RPC _response_ per each received JSON-RPC _request_, unless the [session](_specification_2025-03-26_basic_transports.md#session-management) expires.
    *   After all JSON-RPC _responses_ have been sent, the server **SHOULD** close the SSE stream.
    *   Disconnection **MAY** occur at any time (e.g., due to network conditions). Therefore:
        *   Disconnection **SHOULD NOT** be interpreted as the client cancelling its request.
        *   To cancel, the client **SHOULD** explicitly send an MCP `CancelledNotification`.
        *   To avoid message loss due to disconnection, the server **MAY** make the stream [resumable](_specification_2025-03-26_basic_transports.md#resumability-and-redelivery).

### Listening for Messages from the Server[](_specification_2025-03-26_basic_transports.md#listening-for-messages-from-the-server)

1.  The client **MAY** issue an HTTP GET to the MCP endpoint. This can be used to open an SSE stream, allowing the server to communicate to the client, without the client first sending data via HTTP POST.
2.  The client **MUST** include an `Accept` header, listing `text/event-stream` as a supported content type.
3.  The server **MUST** either return `Content-Type: text/event-stream` in response to this HTTP GET, or else return HTTP 405 Method Not Allowed, indicating that the server does not offer an SSE stream at this endpoint.
4.  If the server initiates an SSE stream:
    *   The server **MAY** send JSON-RPC _requests_ and _notifications_ on the stream. These _requests_ and _notifications_ **MAY** be [batched](https://www.jsonrpc.org/specification#batch).
    *   These messages **SHOULD** be unrelated to any concurrently-running JSON-RPC _request_ from the client.
    *   The server **MUST NOT** send a JSON-RPC _response_ on the stream **unless** [resuming](_specification_2025-03-26_basic_transports.md#resumability-and-redelivery) a stream associated with a previous client request.
    *   The server **MAY** close the SSE stream at any time.
    *   The client **MAY** close the SSE stream at any time.

### Multiple Connections[](_specification_2025-03-26_basic_transports.md#multiple-connections)

1.  The client **MAY** remain connected to multiple SSE streams simultaneously.
2.  The server **MUST** send each of its JSON-RPC messages on only one of the connected streams; that is, it **MUST NOT** broadcast the same message across multiple streams.
    *   The risk of message loss **MAY** be mitigated by making the stream [resumable](_specification_2025-03-26_basic_transports.md#resumability-and-redelivery).

### Resumability and Redelivery[](_specification_2025-03-26_basic_transports.md#resumability-and-redelivery)

To support resuming broken connections, and redelivering messages that might otherwise be lost:

1.  Servers **MAY** attach an `id` field to their SSE events, as described in the [SSE standard](https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation).
    *   If present, the ID **MUST** be globally unique across all streams within that [session](_specification_2025-03-26_basic_transports.md#session-management)—or all streams with that specific client, if session management is not in use.
2.  If the client wishes to resume after a broken connection, it **SHOULD** issue an HTTP GET to the MCP endpoint, and include the [`Last-Event-ID`](https://html.spec.whatwg.org/multipage/server-sent-events.html#the-last-event-id-header) header to indicate the last event ID it received.
    *   The server **MAY** use this header to replay messages that would have been sent after the last event ID, _on the stream that was disconnected_, and to resume the stream from that point.
    *   The server **MUST NOT** replay messages that would have been delivered on a different stream.

In other words, these event IDs should be assigned by servers on a _per-stream_ basis, to act as a cursor within that particular stream.

### Session Management[](_specification_2025-03-26_basic_transports.md#session-management)

An MCP “session” consists of logically related interactions between a client and a server, beginning with the [initialization phase](_specification_2025-03-26_basic_lifecycle_.md). To support servers which want to establish stateful sessions:

1.  A server using the Streamable HTTP transport **MAY** assign a session ID at initialization time, by including it in an `Mcp-Session-Id` header on the HTTP response containing the `InitializeResult`.
    *   The session ID **SHOULD** be globally unique and cryptographically secure (e.g., a securely generated UUID, a JWT, or a cryptographic hash).
    *   The session ID **MUST** only contain visible ASCII characters (ranging from 0x21 to 0x7E).
2.  If an `Mcp-Session-Id` is returned by the server during initialization, clients using the Streamable HTTP transport **MUST** include it in the `Mcp-Session-Id` header on all of their subsequent HTTP requests.
    *   Servers that require a session ID **SHOULD** respond to requests without an `Mcp-Session-Id` header (other than initialization) with HTTP 400 Bad Request.
3.  The server **MAY** terminate the session at any time, after which it **MUST** respond to requests containing that session ID with HTTP 404 Not Found.
4.  When a client receives HTTP 404 in response to a request containing an `Mcp-Session-Id`, it **MUST** start a new session by sending a new `InitializeRequest` without a session ID attached.
5.  Clients that no longer need a particular session (e.g., because the user is leaving the client application) **SHOULD** send an HTTP DELETE to the MCP endpoint with the `Mcp-Session-Id` header, to explicitly terminate the session.
    *   The server **MAY** respond to this request with HTTP 405 Method Not Allowed, indicating that the server does not allow clients to terminate sessions.

### Sequence Diagram[](_specification_2025-03-26_basic_transports.md#sequence-diagram)
```
sequenceDiagram
    participant Client
    participant Server
    note over Client, Server: initialization
    Client->>+Server: POST InitializeRequest
    Server->>-Client: InitializeResponse  
Mcp-Session-Id: 1868a90c...
    Client->>+Server: POST InitializedNotification  
Mcp-Session-Id: 1868a90c...
    Server->>-Client: 202 Accepted
    note over Client, Server: client requests
    Client->>+Server: POST ... request ...  
Mcp-Session-Id: 1868a90c...
    alt single HTTP response
      Server->>Client: ... response ...
    else server opens SSE stream
      loop while connection remains open
          Server-)Client: ... SSE messages from server ...
      end
      Server-)Client: SSE event: ... response ...
    end
    deactivate Server
    note over Client, Server: client notifications/responses
    Client->>+Server: POST ... notification/response ...  
Mcp-Session-Id: 1868a90c...
    Server->>-Client: 202 Accepted
    note over Client, Server: server requests
    Client->>+Server: GET  
Mcp-Session-Id: 1868a90c...
    loop while connection remains open
        Server-)Client: ... SSE messages from server ...
    end
    deactivate Server
```
### Backwards Compatibility[](_specification_2025-03-26_basic_transports.md#backwards-compatibility)

Clients and servers can maintain backwards compatibility with the deprecated [HTTP+SSE transport](_specification_2024-11-05_basic_transports_.md#http-with-sse) (from protocol version 2024-11-05) as follows:

**Servers** wanting to support older clients should:
*   Continue to host both the SSE and POST endpoints of the old transport, alongside the new “MCP endpoint” defined for the Streamable HTTP transport.
    *   It is also possible to combine the old POST endpoint and the new MCP endpoint, but this may introduce unneeded complexity.

**Clients** wanting to support older servers should:

1.  Accept an MCP server URL from the user, which may point to either a server using the old transport or the new transport.
2.  Attempt to POST an `InitializeRequest` to the server URL, with an `Accept` header as defined above:
    *   If it succeeds, the client can assume this is a server supporting the new Streamable HTTP transport.
    *   If it fails with an HTTP 4xx status code (e.g., 405 Method Not Allowed or 404 Not Found):
        *   Issue a GET request to the server URL, expecting that this will open an SSE stream and return an `endpoint` event as the first event.
        *   When the `endpoint` event arrives, the client can assume this is a server running the old HTTP+SSE transport, and should use that transport for all subsequent communication.

## Custom Transports[](_specification_2025-03-26_basic_transports.md#custom-transports)

Clients and servers **MAY** implement additional custom transport mechanisms to suit their specific needs. The protocol is transport-agnostic and can be implemented over any communication channel that supports bidirectional message exchange.

Implementers who choose to support custom transports **MUST** ensure they preserve the JSON-RPC message format and lifecycle requirements defined by MCP. Custom transports **SHOULD** document their specific connection establishment and message exchange patterns to aid interoperability.

#### _specification_2025-03-26_basic_utilities.md

> Source: https://spec.modelcontextprotocol.io/specification/2025-03-26/basic/utilities
> Scraped: 4/2/2025, 4:52:13 PM

⌘K
*   [Specification](_specification_.md)
    
    *   [2025-03-26 (Latest)](_specification_2025-03-26_.md)
        
        *   [Key Changes](_specification_2025-03-26_changelog_.md)
        *   [Architecture](_specification_2025-03-26_architecture_.md)
        *   [Base Protocol](_specification_2025-03-26_basic_.md)
            
            *   [Transports](_specification_2025-03-26_basic_transports_.md)
            *   [Authorization](_specification_2025-03-26_basic_authorization_.md)
            *   [Lifecycle](_specification_2025-03-26_basic_lifecycle_.md)
            *   [Utilities](_specification_2025-03-26_basic_utilities_.md)
                
                *   [Ping](_specification_2025-03-26_basic_utilities_ping_.md)
                *   [Cancellation](_specification_2025-03-26_basic_utilities_cancellation_.md)
                *   [Progress](_specification_2025-03-26_basic_utilities_progress_.md)
                
            
        *   [Server Features](_specification_2025-03-26_server_.md)
            
            *   [Prompts](_specification_2025-03-26_server_prompts_.md)
            *   [Resources](_specification_2025-03-26_server_resources_.md)
            *   [Tools](_specification_2025-03-26_server_tools_.md)
            *   [Utilities](_specification_2025-03-26_server_utilities_.md)
                
                *   [Completion](_specification_2025-03-26_server_utilities_completion_.md)
                *   [Logging](_specification_2025-03-26_server_utilities_logging_.md)
                *   [Pagination](_specification_2025-03-26_server_utilities_pagination_.md)
                
            
        *   [Client Features](_specification_2025-03-26_client_.md)
            
            *   [Roots](_specification_2025-03-26_client_roots_.md)
            *   [Sampling](_specification_2025-03-26_client_sampling_.md)
            
        
    *   [2024-11-05 (Final)](_specification_2024-11-05_.md)
        
        *   [Architecture](_specification_2024-11-05_architecture_.md)
        *   [Base Protocol](_specification_2024-11-05_basic_.md)
            
            *   [Messages](_specification_2024-11-05_basic_messages_.md)
            *   [Lifecycle](_specification_2024-11-05_basic_lifecycle_.md)
            *   [Transports](_specification_2024-11-05_basic_transports_.md)
            *   [Utilities](_specification_2024-11-05_basic_utilities_.md)
                
                *   [Ping](_specification_2024-11-05_basic_utilities_ping_.md)
                *   [Cancellation](_specification_2024-11-05_basic_utilities_cancellation_.md)
                *   [Progress](_specification_2024-11-05_basic_utilities_progress_.md)
                
            
        *   [Server Features](_specification_2024-11-05_server_.md)
            
            *   [Prompts](_specification_2024-11-05_server_prompts_.md)
            *   [Resources](_specification_2024-11-05_server_resources_.md)
            *   [Tools](_specification_2024-11-05_server_tools_.md)
            *   [Utilities](_specification_2024-11-05_server_utilities_.md)
                
                *   [Completion](_specification_2024-11-05_server_utilities_completion_.md)
                *   [Logging](_specification_2024-11-05_server_utilities_logging_.md)
                *   [Pagination](_specification_2024-11-05_server_utilities_pagination_.md)
                
            
        *   [Client Features](_specification_2024-11-05_client_.md)
            
            *   [Roots](_specification_2024-11-05_client_roots_.md)
            *   [Sampling](_specification_2024-11-05_client_sampling_.md)
            
        
    *   [Versioning](_specification_versioning_.md)
    *   [Contributions](_specification_contributing_.md)
    
*   [Schema ↗](https://github.com/modelcontextprotocol/specification/tree/main/schema)
*   More
*   [User Guide ↗](https://modelcontextprotocol.io)
*   [Python SDK ↗](https://github.com/modelcontextprotocol/python-sdk)
*   [TypeScript SDK ↗](https://github.com/modelcontextprotocol/typescript-sdk)
*   [2025-03-26 (Latest)](_specification_2025-03-26_.md)
    
    *   [Key Changes](_specification_2025-03-26_changelog_.md)
    *   [Architecture](_specification_2025-03-26_architecture_.md)
    *   [Base Protocol](_specification_2025-03-26_basic_.md)
        
        *   [Transports](_specification_2025-03-26_basic_transports_.md)
        *   [Authorization](_specification_2025-03-26_basic_authorization_.md)
        *   [Lifecycle](_specification_2025-03-26_basic_lifecycle_.md)
        *   [Utilities](_specification_2025-03-26_basic_utilities_.md)
            
            *   [Ping](_specification_2025-03-26_basic_utilities_ping_.md)
            *   [Cancellation](_specification_2025-03-26_basic_utilities_cancellation_.md)
            *   [Progress](_specification_2025-03-26_basic_utilities_progress_.md)
            
        
    *   [Server Features](_specification_2025-03-26_server_.md)
        
        *   [Prompts](_specification_2025-03-26_server_prompts_.md)
        *   [Resources](_specification_2025-03-26_server_resources_.md)
        *   [Tools](_specification_2025-03-26_server_tools_.md)
        *   [Utilities](_specification_2025-03-26_server_utilities_.md)
            
            *   [Completion](_specification_2025-03-26_server_utilities_completion_.md)
            *   [Logging](_specification_2025-03-26_server_utilities_logging_.md)
            *   [Pagination](_specification_2025-03-26_server_utilities_pagination_.md)
            
        
    *   [Client Features](_specification_2025-03-26_client_.md)
        
        *   [Roots](_specification_2025-03-26_client_roots_.md)
        *   [Sampling](_specification_2025-03-26_client_sampling_.md)
        
    
*   [2024-11-05 (Final)](_specification_2024-11-05_.md)
    
    *   [Architecture](_specification_2024-11-05_architecture_.md)
    *   [Base Protocol](_specification_2024-11-05_basic_.md)
        
        *   [Messages](_specification_2024-11-05_basic_messages_.md)
        *   [Lifecycle](_specification_2024-11-05_basic_lifecycle_.md)
        *   [Transports](_specification_2024-11-05_basic_transports_.md)
        *   [Utilities](_specification_2024-11-05_basic_utilities_.md)
            
            *   [Ping](_specification_2024-11-05_basic_utilities_ping_.md)
            *   [Cancellation](_specification_2024-11-05_basic_utilities_cancellation_.md)
            *   [Progress](_specification_2024-11-05_basic_utilities_progress_.md)
            
        
    *   [Server Features](_specification_2024-11-05_server_.md)
        
        *   [Prompts](_specification_2024-11-05_server_prompts_.md)
        *   [Resources](_specification_2024-11-05_server_resources_.md)
        *   [Tools](_specification_2024-11-05_server_tools_.md)
        *   [Utilities](_specification_2024-11-05_server_utilities_.md)
            
            *   [Completion](_specification_2024-11-05_server_utilities_completion_.md)
            *   [Logging](_specification_2024-11-05_server_utilities_logging_.md)
            *   [Pagination](_specification_2024-11-05_server_utilities_pagination_.md)
            
        
    *   [Client Features](_specification_2024-11-05_client_.md)
        
        *   [Roots](_specification_2024-11-05_client_roots_.md)
        *   [Sampling](_specification_2024-11-05_client_sampling_.md)
        
    
*   [Versioning](_specification_versioning_.md)
*   [Contributions](_specification_contributing_.md)
*   [Schema ↗](https://github.com/modelcontextprotocol/specification/tree/main/schema)
*   More
*   [User Guide ↗](https://modelcontextprotocol.io)
*   [Python SDK ↗](https://github.com/modelcontextprotocol/python-sdk)
*   [TypeScript SDK ↗](https://github.com/modelcontextprotocol/typescript-sdk)

LightDark

[Specification](_specification_.md)

[2025-03-26 (Latest)](_specification_2025-03-26_.md)

[Base Protocol](_specification_2025-03-26_basic_.md)

Utilities

# Utilities

ℹ️

**Protocol Revision**: 2025-03-26

These optional features enhance the base protocol functionality with various utilities.

[Ping](_specification_ping.md) [Cancellation](_specification_cancellation.md) [Progress](_specification_progress.md)

#### _specification_2025-03-26_basic_utilities_cancellation.md

> Source: https://spec.modelcontextprotocol.io/specification/2025-03-26/basic/utilities/cancellation
> Scraped: 4/2/2025, 4:52:13 PM

**Protocol Revision**: 2025-03-26

The Model Context Protocol (MCP) supports optional cancellation of in-progress requests through notification messages. Either side can send a cancellation notification to indicate that a previously-issued request should be terminated.

## Cancellation Flow[](_specification_2025-03-26_basic_utilities_cancellation.md#cancellation-flow)

When a party wants to cancel an in-progress request, it sends a `notifications/cancelled` notification containing:
*   The ID of the request to cancel
*   An optional reason string that can be logged or displayed

## Behavior Requirements[](_specification_2025-03-26_basic_utilities_cancellation.md#behavior-requirements)

1.  Cancellation notifications **MUST** only reference requests that:
    *   Were previously issued in the same direction
    *   Are believed to still be in-progress
2.  The `initialize` request **MUST NOT** be cancelled by clients
3.  Receivers of cancellation notifications **SHOULD**:
    *   Stop processing the cancelled request
    *   Free associated resources
    *   Not send a response for the cancelled request
4.  Receivers **MAY** ignore cancellation notifications if:
    *   The referenced request is unknown
    *   Processing has already completed
    *   The request cannot be cancelled
5.  The sender of the cancellation notification **SHOULD** ignore any response to the request that arrives afterward

## Timing Considerations[](_specification_2025-03-26_basic_utilities_cancellation.md#timing-considerations)

Due to network latency, cancellation notifications may arrive after request processing has completed, and potentially after a response has already been sent.

Both parties **MUST** handle these race conditions gracefully:
```
sequenceDiagram
   participant Client
   participant Server
   Client->>Server: Request (ID: 123)
   Note over Server: Processing starts
   Client--)Server: notifications/cancelled (ID: 123)
   alt
      Note over Server: Processing may have  
completed before  
cancellation arrives
   else If not completed
      Note over Server: Stop processing
   end
```
## Implementation Notes[](_specification_2025-03-26_basic_utilities_cancellation.md#implementation-notes)
*   Both parties **SHOULD** log cancellation reasons for debugging
*   Application UIs **SHOULD** indicate when cancellation is requested

## Error Handling[](_specification_2025-03-26_basic_utilities_cancellation.md#error-handling)

Invalid cancellation notifications **SHOULD** be ignored:
*   Unknown request IDs
*   Already completed requests
*   Malformed notifications

This maintains the “fire and forget” nature of notifications while allowing for race conditions in asynchronous communication.

#### _specification_2025-03-26_basic_utilities_ping.md

> Source: https://spec.modelcontextprotocol.io/specification/2025-03-26/basic/utilities/ping
> Scraped: 4/2/2025, 4:52:13 PM

**Protocol Revision**: 2025-03-26

The Model Context Protocol includes an optional ping mechanism that allows either party to verify that their counterpart is still responsive and the connection is alive.

## Overview[](_specification_2025-03-26_basic_utilities_ping.md#overview)

The ping functionality is implemented through a simple request/response pattern. Either the client or server can initiate a ping by sending a `ping` request.

## Message Format[](_specification_2025-03-26_basic_utilities_ping.md#message-format)

A ping request is a standard JSON-RPC request with no parameters:

## Behavior Requirements[](_specification_2025-03-26_basic_utilities_ping.md#behavior-requirements)

1.  The receiver **MUST** respond promptly with an empty response:

1.  If no response is received within a reasonable timeout period, the sender **MAY**:
    *   Consider the connection stale
    *   Terminate the connection
    *   Attempt reconnection procedures

## Usage Patterns[](_specification_2025-03-26_basic_utilities_ping.md#usage-patterns)
```
sequenceDiagram
    participant Sender
    participant Receiver
    Sender->>Receiver: ping request
    Receiver->>Sender: empty response
```
## Implementation Considerations[](_specification_2025-03-26_basic_utilities_ping.md#implementation-considerations)
*   Implementations **SHOULD** periodically issue pings to detect connection health
*   The frequency of pings **SHOULD** be configurable
*   Timeouts **SHOULD** be appropriate for the network environment
*   Excessive pinging **SHOULD** be avoided to reduce network overhead

## Error Handling[](_specification_2025-03-26_basic_utilities_ping.md#error-handling)
*   Timeouts **SHOULD** be treated as connection failures
*   Multiple failed pings **MAY** trigger connection reset
*   Implementations **SHOULD** log ping failures for diagnostics

#### _specification_2025-03-26_basic_utilities_progress.md

> Source: https://spec.modelcontextprotocol.io/specification/2025-03-26/basic/utilities/progress
> Scraped: 4/2/2025, 4:52:12 PM

**Protocol Revision**: 2025-03-26

The Model Context Protocol (MCP) supports optional progress tracking for long-running operations through notification messages. Either side can send progress notifications to provide updates about operation status.

## Progress Flow[](_specification_2025-03-26_basic_utilities_progress.md#progress-flow)

When a party wants to _receive_ progress updates for a request, it includes a `progressToken` in the request metadata.
*   Progress tokens **MUST** be a string or integer value
*   Progress tokens can be chosen by the sender using any means, but **MUST** be unique across all active requests.

The receiver **MAY** then send progress notifications containing:
*   The original progress token
*   The current progress value so far
*   An optional “total” value
*   An optional “message” value
*   The `progress` value **MUST** increase with each notification, even if the total is unknown.
*   The `progress` and the `total` values **MAY** be floating point.
*   The `message` field **SHOULD** provide relevant human readable progress information.

## Behavior Requirements[](_specification_2025-03-26_basic_utilities_progress.md#behavior-requirements)

1.  Progress notifications **MUST** only reference tokens that:
    
    *   Were provided in an active request
    *   Are associated with an in-progress operation
2.  Receivers of progress requests **MAY**:
    
    *   Choose not to send any progress notifications
    *   Send notifications at whatever frequency they deem appropriate
    *   Omit the total value if unknown
```
sequenceDiagram
    participant Sender
    participant Receiver
    Note over Sender,Receiver: Request with progress token
    Sender->>Receiver: Method request with progressToken
    Note over Sender,Receiver: Progress updates
    loop Progress Updates
        Receiver-->>Sender: Progress notification (0.2/1.0)
        Receiver-->>Sender: Progress notification (0.6/1.0)
        Receiver-->>Sender: Progress notification (1.0/1.0)
    end
    Note over Sender,Receiver: Operation complete
    Receiver->>Sender: Method response
```
## Implementation Notes[](_specification_2025-03-26_basic_utilities_progress.md#implementation-notes)
*   Senders and receivers **SHOULD** track active progress tokens
*   Both parties **SHOULD** implement rate limiting to prevent flooding
*   Progress notifications **MUST** stop after completion

#### _specification_2025-03-26_changelog.md

> Source: https://spec.modelcontextprotocol.io/specification/2025-03-26/changelog
> Scraped: 4/2/2025, 4:52:12 PM

This document lists changes made to the Model Context Protocol (MCP) specification since the previous revision, [2024-11-05](_specification_2024-11-05_.md).

## Major changes[](_specification_2025-03-26_changelog.md#major-changes)

1.  Added a comprehensive **[authorization framework](_specification_2025-03-26_basic_authorization_.md)** based on OAuth 2.1 (PR [#133](https://github.com/modelcontextprotocol/specification/pull/133))
2.  Replaced the previous HTTP+SSE transport with a more flexible **[Streamable HTTP transport](_specification_2025-03-26_basic_transports_.md#streamable-http)** (PR [#206](https://github.com/modelcontextprotocol/specification/pull/206))
3.  Added support for JSON-RPC **[batching](https://www.jsonrpc.org/specification#batch)** (PR [#228](https://github.com/modelcontextprotocol/specification/pull/228))
4.  Added comprehensive **tool annotations** for better describing tool behavior, like whether it is read-only or destructive (PR [#185](https://github.com/modelcontextprotocol/specification/pull/185))

## Other schema changes[](_specification_2025-03-26_changelog.md#other-schema-changes)
*   Added `message` field to `ProgressNotification` to provide descriptive status updates
*   Added support for audio data, joining the existing text and image content types
*   Added `completions` capability to explicitly indicate support for argument autocompletion suggestions

See [the updated schema](http://github.com/modelcontextprotocol/specification/tree/main/schema/2025-03-26/schema.ts) for more details.

## Full changelog[](_specification_2025-03-26_changelog.md#full-changelog)

For a complete list of all changes that have been made since the last protocol revision, [see GitHub](https://github.com/modelcontextprotocol/specification/compare/2024-11-05...2025-03-26).

#### _specification_2025-03-26_client.md

> Source: https://spec.modelcontextprotocol.io/specification/2025-03-26/client
> Scraped: 4/2/2025, 4:52:14 PM

⌘K
*   [Specification](_specification_.md)
    
    *   [2025-03-26 (Latest)](_specification_2025-03-26_.md)
        
        *   [Key Changes](_specification_2025-03-26_changelog_.md)
        *   [Architecture](_specification_2025-03-26_architecture_.md)
        *   [Base Protocol](_specification_2025-03-26_basic_.md)
            
            *   [Transports](_specification_2025-03-26_basic_transports_.md)
            *   [Authorization](_specification_2025-03-26_basic_authorization_.md)
            *   [Lifecycle](_specification_2025-03-26_basic_lifecycle_.md)
            *   [Utilities](_specification_2025-03-26_basic_utilities_.md)
                
                *   [Ping](_specification_2025-03-26_basic_utilities_ping_.md)
                *   [Cancellation](_specification_2025-03-26_basic_utilities_cancellation_.md)
                *   [Progress](_specification_2025-03-26_basic_utilities_progress_.md)
                
            
        *   [Server Features](_specification_2025-03-26_server_.md)
            
            *   [Prompts](_specification_2025-03-26_server_prompts_.md)
            *   [Resources](_specification_2025-03-26_server_resources_.md)
            *   [Tools](_specification_2025-03-26_server_tools_.md)
            *   [Utilities](_specification_2025-03-26_server_utilities_.md)
                
                *   [Completion](_specification_2025-03-26_server_utilities_completion_.md)
                *   [Logging](_specification_2025-03-26_server_utilities_logging_.md)
                *   [Pagination](_specification_2025-03-26_server_utilities_pagination_.md)
                
            
        *   [Client Features](_specification_2025-03-26_client_.md)
            
            *   [Roots](_specification_2025-03-26_client_roots_.md)
            *   [Sampling](_specification_2025-03-26_client_sampling_.md)
            
        
    *   [2024-11-05 (Final)](_specification_2024-11-05_.md)
        
        *   [Architecture](_specification_2024-11-05_architecture_.md)
        *   [Base Protocol](_specification_2024-11-05_basic_.md)
            
            *   [Messages](_specification_2024-11-05_basic_messages_.md)
            *   [Lifecycle](_specification_2024-11-05_basic_lifecycle_.md)
            *   [Transports](_specification_2024-11-05_basic_transports_.md)
            *   [Utilities](_specification_2024-11-05_basic_utilities_.md)
                
                *   [Ping](_specification_2024-11-05_basic_utilities_ping_.md)
                *   [Cancellation](_specification_2024-11-05_basic_utilities_cancellation_.md)
                *   [Progress](_specification_2024-11-05_basic_utilities_progress_.md)
                
            
        *   [Server Features](_specification_2024-11-05_server_.md)
            
            *   [Prompts](_specification_2024-11-05_server_prompts_.md)
            *   [Resources](_specification_2024-11-05_server_resources_.md)
            *   [Tools](_specification_2024-11-05_server_tools_.md)
            *   [Utilities](_specification_2024-11-05_server_utilities_.md)
                
                *   [Completion](_specification_2024-11-05_server_utilities_completion_.md)
                *   [Logging](_specification_2024-11-05_server_utilities_logging_.md)
                *   [Pagination](_specification_2024-11-05_server_utilities_pagination_.md)
                
            
        *   [Client Features](_specification_2024-11-05_client_.md)
            
            *   [Roots](_specification_2024-11-05_client_roots_.md)
            *   [Sampling](_specification_2024-11-05_client_sampling_.md)
            
        
    *   [Versioning](_specification_versioning_.md)
    *   [Contributions](_specification_contributing_.md)
    
*   [Schema ↗](https://github.com/modelcontextprotocol/specification/tree/main/schema)
*   More
*   [User Guide ↗](https://modelcontextprotocol.io)
*   [Python SDK ↗](https://github.com/modelcontextprotocol/python-sdk)
*   [TypeScript SDK ↗](https://github.com/modelcontextprotocol/typescript-sdk)
*   [2025-03-26 (Latest)](_specification_2025-03-26_.md)
    
    *   [Key Changes](_specification_2025-03-26_changelog_.md)
    *   [Architecture](_specification_2025-03-26_architecture_.md)
    *   [Base Protocol](_specification_2025-03-26_basic_.md)
        
        *   [Transports](_specification_2025-03-26_basic_transports_.md)
        *   [Authorization](_specification_2025-03-26_basic_authorization_.md)
        *   [Lifecycle](_specification_2025-03-26_basic_lifecycle_.md)
        *   [Utilities](_specification_2025-03-26_basic_utilities_.md)
            
            *   [Ping](_specification_2025-03-26_basic_utilities_ping_.md)
            *   [Cancellation](_specification_2025-03-26_basic_utilities_cancellation_.md)
            *   [Progress](_specification_2025-03-26_basic_utilities_progress_.md)
            
        
    *   [Server Features](_specification_2025-03-26_server_.md)
        
        *   [Prompts](_specification_2025-03-26_server_prompts_.md)
        *   [Resources](_specification_2025-03-26_server_resources_.md)
        *   [Tools](_specification_2025-03-26_server_tools_.md)
        *   [Utilities](_specification_2025-03-26_server_utilities_.md)
            
            *   [Completion](_specification_2025-03-26_server_utilities_completion_.md)
            *   [Logging](_specification_2025-03-26_server_utilities_logging_.md)
            *   [Pagination](_specification_2025-03-26_server_utilities_pagination_.md)
            
        
    *   [Client Features](_specification_2025-03-26_client_.md)
        
        *   [Roots](_specification_2025-03-26_client_roots_.md)
        *   [Sampling](_specification_2025-03-26_client_sampling_.md)
        
    
*   [2024-11-05 (Final)](_specification_2024-11-05_.md)
    
    *   [Architecture](_specification_2024-11-05_architecture_.md)
    *   [Base Protocol](_specification_2024-11-05_basic_.md)
        
        *   [Messages](_specification_2024-11-05_basic_messages_.md)
        *   [Lifecycle](_specification_2024-11-05_basic_lifecycle_.md)
        *   [Transports](_specification_2024-11-05_basic_transports_.md)
        *   [Utilities](_specification_2024-11-05_basic_utilities_.md)
            
            *   [Ping](_specification_2024-11-05_basic_utilities_ping_.md)
            *   [Cancellation](_specification_2024-11-05_basic_utilities_cancellation_.md)
            *   [Progress](_specification_2024-11-05_basic_utilities_progress_.md)
            
        
    *   [Server Features](_specification_2024-11-05_server_.md)
        
        *   [Prompts](_specification_2024-11-05_server_prompts_.md)
        *   [Resources](_specification_2024-11-05_server_resources_.md)
        *   [Tools](_specification_2024-11-05_server_tools_.md)
        *   [Utilities](_specification_2024-11-05_server_utilities_.md)
            
            *   [Completion](_specification_2024-11-05_server_utilities_completion_.md)
            *   [Logging](_specification_2024-11-05_server_utilities_logging_.md)
            *   [Pagination](_specification_2024-11-05_server_utilities_pagination_.md)
            
        
    *   [Client Features](_specification_2024-11-05_client_.md)
        
        *   [Roots](_specification_2024-11-05_client_roots_.md)
        *   [Sampling](_specification_2024-11-05_client_sampling_.md)
        
    
*   [Versioning](_specification_versioning_.md)
*   [Contributions](_specification_contributing_.md)
*   [Schema ↗](https://github.com/modelcontextprotocol/specification/tree/main/schema)
*   More
*   [User Guide ↗](https://modelcontextprotocol.io)
*   [Python SDK ↗](https://github.com/modelcontextprotocol/python-sdk)
*   [TypeScript SDK ↗](https://github.com/modelcontextprotocol/typescript-sdk)

LightDark

[Specification](_specification_.md)

[2025-03-26 (Latest)](_specification_2025-03-26_.md)

Client Features

# Client Features

ℹ️

**Protocol Revision**: 2025-03-26

Clients can implement additional features to enrich connected MCP servers:

[Roots](_specification_roots.md) [Sampling](_specification_sampling.md)

#### _specification_2025-03-26_server.md

> Source: https://spec.modelcontextprotocol.io/specification/2025-03-26/server
> Scraped: 4/2/2025, 4:52:13 PM

**Protocol Revision**: 2025-03-26

Servers provide the fundamental building blocks for adding context to language models via MCP. These primitives enable rich interactions between clients, servers, and language models:
*   **Prompts**: Pre-defined templates or instructions that guide language model interactions
*   **Resources**: Structured data or content that provides additional context to the model
*   **Tools**: Executable functions that allow models to perform actions or retrieve information

Each primitive can be summarized in the following control hierarchy:

Primitive

Control

Description

Example

Prompts

User-controlled

Interactive templates invoked by user choice

Slash commands, menu options

Resources

Application-controlled

Contextual data attached and managed by the client

File contents, git history

Tools

Model-controlled

Functions exposed to the LLM to take actions

API POST requests, file writing

Explore these key primitives in more detail below:

#### _specification_2025-03-26_server_prompts.md

> Source: https://spec.modelcontextprotocol.io/specification/2025-03-26/server/prompts
> Scraped: 4/2/2025, 4:52:14 PM

**Protocol Revision**: 2025-03-26

The Model Context Protocol (MCP) provides a standardized way for servers to expose prompt templates to clients. Prompts allow servers to provide structured messages and instructions for interacting with language models. Clients can discover available prompts, retrieve their contents, and provide arguments to customize them.

## User Interaction Model[](_specification_2025-03-26_server_prompts.md#user-interaction-model)

Prompts are designed to be **user-controlled**, meaning they are exposed from servers to clients with the intention of the user being able to explicitly select them for use.

Typically, prompts would be triggered through user-initiated commands in the user interface, which allows users to naturally discover and invoke available prompts.

For example, as slash commands:

![Example of prompt exposed as slash command](https://spec.modelcontextprotocol.io/specification/2025-03-26/slash-command.png)

However, implementors are free to expose prompts through any interface pattern that suits their needs—the protocol itself does not mandate any specific user interaction model.

## Capabilities[](_specification_2025-03-26_server_prompts.md#capabilities)

Servers that support prompts **MUST** declare the `prompts` capability during [initialization](_specification_2025-03-26_basic_lifecycle_.md#initialization):

`listChanged` indicates whether the server will emit notifications when the list of available prompts changes.

## Protocol Messages[](_specification_2025-03-26_server_prompts.md#protocol-messages)

### Listing Prompts[](_specification_2025-03-26_server_prompts.md#listing-prompts)

To retrieve available prompts, clients send a `prompts/list` request. This operation supports [pagination](_specification_2025-03-26_server_utilities_pagination_.md).

**Request:***Response:**

### Getting a Prompt[](_specification_2025-03-26_server_prompts.md#getting-a-prompt)

To retrieve a specific prompt, clients send a `prompts/get` request. Arguments may be auto-completed through [the completion API](_specification_2025-03-26_server_utilities_completion_.md).

**Request:***Response:**

### List Changed Notification[](_specification_2025-03-26_server_prompts.md#list-changed-notification)

When the list of available prompts changes, servers that declared the `listChanged` capability **SHOULD** send a notification:

## Message Flow[](_specification_2025-03-26_server_prompts.md#message-flow)
```
sequenceDiagram
    participant Client
    participant Server
    Note over Client,Server: Discovery
    Client->>Server: prompts/list
    Server-->>Client: List of prompts
    Note over Client,Server: Usage
    Client->>Server: prompts/get
    Server-->>Client: Prompt content
    opt listChanged
      Note over Client,Server: Changes
      Server--)Client: prompts/list\_changed
      Client->>Server: prompts/list
      Server-->>Client: Updated prompts
    end
```
## Data Types[](_specification_2025-03-26_server_prompts.md#data-types)

### Prompt[](_specification_2025-03-26_server_prompts.md#prompt)

A prompt definition includes:
*   `name`: Unique identifier for the prompt
*   `description`: Optional human-readable description
*   `arguments`: Optional list of arguments for customization

### PromptMessage[](_specification_2025-03-26_server_prompts.md#promptmessage)

Messages in a prompt can contain:
*   `role`: Either “user” or “assistant” to indicate the speaker
*   `content`: One of the following content types:

#### Text Content[](_specification_2025-03-26_server_prompts.md#text-content)

Text content represents plain text messages:

This is the most common content type used for natural language interactions.

#### Image Content[](_specification_2025-03-26_server_prompts.md#image-content)

Image content allows including visual information in messages:

The image data **MUST** be base64-encoded and include a valid MIME type. This enables multi-modal interactions where visual context is important.

#### Audio Content[](_specification_2025-03-26_server_prompts.md#audio-content)

Audio content allows including audio information in messages:

The audio data MUST be base64-encoded and include a valid MIME type. This enables multi-modal interactions where audio context is important.

#### Embedded Resources[](_specification_2025-03-26_server_prompts.md#embedded-resources)

Embedded resources allow referencing server-side resources directly in messages:

Resources can contain either text or binary (blob) data and **MUST** include:
*   A valid resource URI
*   The appropriate MIME type
*   Either text content or base64-encoded blob data

Embedded resources enable prompts to seamlessly incorporate server-managed content like documentation, code samples, or other reference materials directly into the conversation flow.

## Error Handling[](_specification_2025-03-26_server_prompts.md#error-handling)

Servers **SHOULD** return standard JSON-RPC errors for common failure cases:
*   Invalid prompt name: `-32602` (Invalid params)
*   Missing required arguments: `-32602` (Invalid params)
*   Internal errors: `-32603` (Internal error)

## Implementation Considerations[](_specification_2025-03-26_server_prompts.md#implementation-considerations)

1.  Servers **SHOULD** validate prompt arguments before processing
2.  Clients **SHOULD** handle pagination for large prompt lists
3.  Both parties **SHOULD** respect capability negotiation

## Security[](_specification_2025-03-26_server_prompts.md#security)

Implementations **MUST** carefully validate all prompt inputs and outputs to prevent injection attacks or unauthorized access to resources.

#### _specification_2025-03-26_server_resources.md

> Source: https://spec.modelcontextprotocol.io/specification/2025-03-26/server/resources
> Scraped: 4/2/2025, 4:52:15 PM

**Protocol Revision**: 2025-03-26

The Model Context Protocol (MCP) provides a standardized way for servers to expose resources to clients. Resources allow servers to share data that provides context to language models, such as files, database schemas, or application-specific information. Each resource is uniquely identified by a [URI](https://datatracker.ietf.org/doc/html/rfc3986).

## User Interaction Model[](_specification_2025-03-26_server_resources.md#user-interaction-model)

Resources in MCP are designed to be **application-driven**, with host applications determining how to incorporate context based on their needs.

For example, applications could:
*   Expose resources through UI elements for explicit selection, in a tree or list view
*   Allow the user to search through and filter available resources
*   Implement automatic context inclusion, based on heuristics or the AI model’s selection

![Example of resource context picker](https://spec.modelcontextprotocol.io/specification/2025-03-26/resource-picker.png)

However, implementations are free to expose resources through any interface pattern that suits their needs—the protocol itself does not mandate any specific user interaction model.

## Capabilities[](_specification_2025-03-26_server_resources.md#capabilities)

Servers that support resources **MUST** declare the `resources` capability:

The capability supports two optional features:
*   `subscribe`: whether the client can subscribe to be notified of changes to individual resources.
*   `listChanged`: whether the server will emit notifications when the list of available resources changes.

Both `subscribe` and `listChanged` are optional—servers can support neither, either, or both:

## Protocol Messages[](_specification_2025-03-26_server_resources.md#protocol-messages)

### Listing Resources[](_specification_2025-03-26_server_resources.md#listing-resources)

To discover available resources, clients send a `resources/list` request. This operation supports [pagination](_specification_2025-03-26_server_utilities_pagination_.md).

**Request:***Response:**

### Reading Resources[](_specification_2025-03-26_server_resources.md#reading-resources)

To retrieve resource contents, clients send a `resources/read` request:

**Request:***Response:**

### Resource Templates[](_specification_2025-03-26_server_resources.md#resource-templates)

Resource templates allow servers to expose parameterized resources using [URI templates](https://datatracker.ietf.org/doc/html/rfc6570). Arguments may be auto-completed through [the completion API](_specification_2025-03-26_server_utilities_completion_.md).

**Request:***Response:**

### List Changed Notification[](_specification_2025-03-26_server_resources.md#list-changed-notification)

When the list of available resources changes, servers that declared the `listChanged` capability **SHOULD** send a notification:

### Subscriptions[](_specification_2025-03-26_server_resources.md#subscriptions)

The protocol supports optional subscriptions to resource changes. Clients can subscribe to specific resources and receive notifications when they change:

**Subscribe Request:***Update Notification:**

## Message Flow[](_specification_2025-03-26_server_resources.md#message-flow)
```
sequenceDiagram
    participant Client
    participant Server
    Note over Client,Server: Resource Discovery
    Client->>Server: resources/list
    Server-->>Client: List of resources
    Note over Client,Server: Resource Access
    Client->>Server: resources/read
    Server-->>Client: Resource contents
    Note over Client,Server: Subscriptions
    Client->>Server: resources/subscribe
    Server-->>Client: Subscription confirmed
    Note over Client,Server: Updates
    Server--)Client: notifications/resources/updated
    Client->>Server: resources/read
    Server-->>Client: Updated contents
```
## Data Types[](_specification_2025-03-26_server_resources.md#data-types)

### Resource[](_specification_2025-03-26_server_resources.md#resource)

A resource definition includes:
*   `uri`: Unique identifier for the resource
*   `name`: Human-readable name
*   `description`: Optional description
*   `mimeType`: Optional MIME type
*   `size`: Optional size in bytes

### Resource Contents[](_specification_2025-03-26_server_resources.md#resource-contents)

Resources can contain either text or binary data:

#### Text Content[](_specification_2025-03-26_server_resources.md#text-content)

#### Binary Content[](_specification_2025-03-26_server_resources.md#binary-content)

## Common URI Schemes[](_specification_2025-03-26_server_resources.md#common-uri-schemes)

The protocol defines several standard URI schemes. This list not exhaustive—implementations are always free to use additional, custom URI schemes.

### https://[](_specification_2025-03-26_server_resources.md#https)

Used to represent a resource available on the web.

Servers **SHOULD** use this scheme only when the client is able to fetch and load the resource directly from the web on its own—that is, it doesn’t need to read the resource via the MCP server.

For other use cases, servers **SHOULD** prefer to use another URI scheme, or define a custom one, even if the server will itself be downloading resource contents over the internet.

### file://[](_specification_2025-03-26_server_resources.md#file)

Used to identify resources that behave like a filesystem. However, the resources do not need to map to an actual physical filesystem.

MCP servers **MAY** identify file:// resources with an [XDG MIME type](https://specifications.freedesktop.org/shared-mime-info-spec/0.14/ar01s02.html#id-1.3.14), like `inode/directory`, to represent non-regular files (such as directories) that don’t otherwise have a standard MIME type.

### git://[](_specification_2025-03-26_server_resources.md#git)

Git version control integration.

## Error Handling[](_specification_2025-03-26_server_resources.md#error-handling)

Servers **SHOULD** return standard JSON-RPC errors for common failure cases:
*   Resource not found: `-32002`
*   Internal errors: `-32603`

Example error:

## Security Considerations[](_specification_2025-03-26_server_resources.md#security-considerations)

1.  Servers **MUST** validate all resource URIs
2.  Access controls **SHOULD** be implemented for sensitive resources
3.  Binary data **MUST** be properly encoded
4.  Resource permissions **SHOULD** be checked before operations

#### _specification_2025-03-26_server_tools.md

> Source: https://spec.modelcontextprotocol.io/specification/2025-03-26/server/tools
> Scraped: 4/2/2025, 4:52:15 PM

**Protocol Revision**: 2025-03-26

The Model Context Protocol (MCP) allows servers to expose tools that can be invoked by language models. Tools enable models to interact with external systems, such as querying databases, calling APIs, or performing computations. Each tool is uniquely identified by a name and includes metadata describing its schema.

## User Interaction Model[](_specification_2025-03-26_server_tools.md#user-interaction-model)

Tools in MCP are designed to be **model-controlled**, meaning that the language model can discover and invoke tools automatically based on its contextual understanding and the user’s prompts.

However, implementations are free to expose tools through any interface pattern that suits their needs—the protocol itself does not mandate any specific user interaction model.

For trust & safety and security, there **SHOULD** always be a human in the loop with the ability to deny tool invocations.

Applications **SHOULD**:
*   Provide UI that makes clear which tools are being exposed to the AI model
*   Insert clear visual indicators when tools are invoked
*   Present confirmation prompts to the user for operations, to ensure a human is in the loop

## Capabilities[](_specification_2025-03-26_server_tools.md#capabilities)

Servers that support tools **MUST** declare the `tools` capability:

`listChanged` indicates whether the server will emit notifications when the list of available tools changes.

## Protocol Messages[](_specification_2025-03-26_server_tools.md#protocol-messages)

### Listing Tools[](_specification_2025-03-26_server_tools.md#listing-tools)

To discover available tools, clients send a `tools/list` request. This operation supports [pagination](_specification_2025-03-26_server_utilities_pagination_.md).

**Request:***Response:**

### Calling Tools[](_specification_2025-03-26_server_tools.md#calling-tools)

To invoke a tool, clients send a `tools/call` request:

**Request:***Response:**

### List Changed Notification[](_specification_2025-03-26_server_tools.md#list-changed-notification)

When the list of available tools changes, servers that declared the `listChanged` capability **SHOULD** send a notification:

## Message Flow[](_specification_2025-03-26_server_tools.md#message-flow)
```
sequenceDiagram
    participant LLM
    participant Client
    participant Server
    Note over Client,Server: Discovery
    Client->>Server: tools/list
    Server-->>Client: List of tools
    Note over Client,LLM: Tool Selection
    LLM->>Client: Select tool to use
    Note over Client,Server: Invocation
    Client->>Server: tools/call
    Server-->>Client: Tool result
    Client->>LLM: Process result
    Note over Client,Server: Updates
    Server--)Client: tools/list\_changed
    Client->>Server: tools/list
    Server-->>Client: Updated tools
```
## Data Types[](_specification_2025-03-26_server_tools.md#data-types)

### Tool[](_specification_2025-03-26_server_tools.md#tool)

A tool definition includes:
*   `name`: Unique identifier for the tool
*   `description`: Human-readable description of functionality
*   `inputSchema`: JSON Schema defining expected parameters
*   `annotations`: optional properties describing tool behavior

For trust & safety and security, clients **MUST** consider tool annotations to be untrusted unless they come from trusted servers.

### Tool Result[](_specification_2025-03-26_server_tools.md#tool-result)

Tool results can contain multiple content items of different types:

#### Text Content[](_specification_2025-03-26_server_tools.md#text-content)

#### Image Content[](_specification_2025-03-26_server_tools.md#image-content)

#### Audio Content[](_specification_2025-03-26_server_tools.md#audio-content)

#### Embedded Resources[](_specification_2025-03-26_server_tools.md#embedded-resources)

[Resources](_specification_2025-03-26_server_resources_.md) **MAY** be embedded, to provide additional context or data, behind a URI that can be subscribed to or fetched again by the client later:

## Error Handling[](_specification_2025-03-26_server_tools.md#error-handling)

Tools use two error reporting mechanisms:

1.  **Protocol Errors**: Standard JSON-RPC errors for issues like:
    
    *   Unknown tools
    *   Invalid arguments
    *   Server errors
2.  **Tool Execution Errors**: Reported in tool results with `isError: true`:
    
    *   API failures
    *   Invalid input data
    *   Business logic errors

Example protocol error:

Example tool execution error:

## Security Considerations[](_specification_2025-03-26_server_tools.md#security-considerations)

1.  Servers **MUST**:
    
    *   Validate all tool inputs
    *   Implement proper access controls
    *   Rate limit tool invocations
    *   Sanitize tool outputs
2.  Clients **SHOULD**:
    
    *   Prompt for user confirmation on sensitive operations
    *   Show tool inputs to the user before calling the server, to avoid malicious or accidental data exfiltration
    *   Validate tool results before passing to LLM
    *   Implement timeouts for tool calls
    *   Log tool usage for audit purposes

#### _specification_2025-03-26_server_utilities.md

> Source: https://spec.modelcontextprotocol.io/specification/2025-03-26/server/utilities
> Scraped: 4/2/2025, 4:52:15 PM

⌘K
*   [Specification](_specification_.md)
    
    *   [2025-03-26 (Latest)](_specification_2025-03-26_.md)
        
        *   [Key Changes](_specification_2025-03-26_changelog_.md)
        *   [Architecture](_specification_2025-03-26_architecture_.md)
        *   [Base Protocol](_specification_2025-03-26_basic_.md)
            
            *   [Transports](_specification_2025-03-26_basic_transports_.md)
            *   [Authorization](_specification_2025-03-26_basic_authorization_.md)
            *   [Lifecycle](_specification_2025-03-26_basic_lifecycle_.md)
            *   [Utilities](_specification_2025-03-26_basic_utilities_.md)
                
                *   [Ping](_specification_2025-03-26_basic_utilities_ping_.md)
                *   [Cancellation](_specification_2025-03-26_basic_utilities_cancellation_.md)
                *   [Progress](_specification_2025-03-26_basic_utilities_progress_.md)
                
            
        *   [Server Features](_specification_2025-03-26_server_.md)
            
            *   [Prompts](_specification_2025-03-26_server_prompts_.md)
            *   [Resources](_specification_2025-03-26_server_resources_.md)
            *   [Tools](_specification_2025-03-26_server_tools_.md)
            *   [Utilities](_specification_2025-03-26_server_utilities_.md)
                
                *   [Completion](_specification_2025-03-26_server_utilities_completion_.md)
                *   [Logging](_specification_2025-03-26_server_utilities_logging_.md)
                *   [Pagination](_specification_2025-03-26_server_utilities_pagination_.md)
                
            
        *   [Client Features](_specification_2025-03-26_client_.md)
            
            *   [Roots](_specification_2025-03-26_client_roots_.md)
            *   [Sampling](_specification_2025-03-26_client_sampling_.md)
            
        
    *   [2024-11-05 (Final)](_specification_2024-11-05_.md)
        
        *   [Architecture](_specification_2024-11-05_architecture_.md)
        *   [Base Protocol](_specification_2024-11-05_basic_.md)
            
            *   [Messages](_specification_2024-11-05_basic_messages_.md)
            *   [Lifecycle](_specification_2024-11-05_basic_lifecycle_.md)
            *   [Transports](_specification_2024-11-05_basic_transports_.md)
            *   [Utilities](_specification_2024-11-05_basic_utilities_.md)
                
                *   [Ping](_specification_2024-11-05_basic_utilities_ping_.md)
                *   [Cancellation](_specification_2024-11-05_basic_utilities_cancellation_.md)
                *   [Progress](_specification_2024-11-05_basic_utilities_progress_.md)
                
            
        *   [Server Features](_specification_2024-11-05_server_.md)
            
            *   [Prompts](_specification_2024-11-05_server_prompts_.md)
            *   [Resources](_specification_2024-11-05_server_resources_.md)
            *   [Tools](_specification_2024-11-05_server_tools_.md)
            *   [Utilities](_specification_2024-11-05_server_utilities_.md)
                
                *   [Completion](_specification_2024-11-05_server_utilities_completion_.md)
                *   [Logging](_specification_2024-11-05_server_utilities_logging_.md)
                *   [Pagination](_specification_2024-11-05_server_utilities_pagination_.md)
                
            
        *   [Client Features](_specification_2024-11-05_client_.md)
            
            *   [Roots](_specification_2024-11-05_client_roots_.md)
            *   [Sampling](_specification_2024-11-05_client_sampling_.md)
            
        
    *   [Versioning](_specification_versioning_.md)
    *   [Contributions](_specification_contributing_.md)
    
*   [Schema ↗](https://github.com/modelcontextprotocol/specification/tree/main/schema)
*   More
*   [User Guide ↗](https://modelcontextprotocol.io)
*   [Python SDK ↗](https://github.com/modelcontextprotocol/python-sdk)
*   [TypeScript SDK ↗](https://github.com/modelcontextprotocol/typescript-sdk)
*   [2025-03-26 (Latest)](_specification_2025-03-26_.md)
    
    *   [Key Changes](_specification_2025-03-26_changelog_.md)
    *   [Architecture](_specification_2025-03-26_architecture_.md)
    *   [Base Protocol](_specification_2025-03-26_basic_.md)
        
        *   [Transports](_specification_2025-03-26_basic_transports_.md)
        *   [Authorization](_specification_2025-03-26_basic_authorization_.md)
        *   [Lifecycle](_specification_2025-03-26_basic_lifecycle_.md)
        *   [Utilities](_specification_2025-03-26_basic_utilities_.md)
            
            *   [Ping](_specification_2025-03-26_basic_utilities_ping_.md)
            *   [Cancellation](_specification_2025-03-26_basic_utilities_cancellation_.md)
            *   [Progress](_specification_2025-03-26_basic_utilities_progress_.md)
            
        
    *   [Server Features](_specification_2025-03-26_server_.md)
        
        *   [Prompts](_specification_2025-03-26_server_prompts_.md)
        *   [Resources](_specification_2025-03-26_server_resources_.md)
        *   [Tools](_specification_2025-03-26_server_tools_.md)
        *   [Utilities](_specification_2025-03-26_server_utilities_.md)
            
            *   [Completion](_specification_2025-03-26_server_utilities_completion_.md)
            *   [Logging](_specification_2025-03-26_server_utilities_logging_.md)
            *   [Pagination](_specification_2025-03-26_server_utilities_pagination_.md)
            
        
    *   [Client Features](_specification_2025-03-26_client_.md)
        
        *   [Roots](_specification_2025-03-26_client_roots_.md)
        *   [Sampling](_specification_2025-03-26_client_sampling_.md)
        
    
*   [2024-11-05 (Final)](_specification_2024-11-05_.md)
    
    *   [Architecture](_specification_2024-11-05_architecture_.md)
    *   [Base Protocol](_specification_2024-11-05_basic_.md)
        
        *   [Messages](_specification_2024-11-05_basic_messages_.md)
        *   [Lifecycle](_specification_2024-11-05_basic_lifecycle_.md)
        *   [Transports](_specification_2024-11-05_basic_transports_.md)
        *   [Utilities](_specification_2024-11-05_basic_utilities_.md)
            
            *   [Ping](_specification_2024-11-05_basic_utilities_ping_.md)
            *   [Cancellation](_specification_2024-11-05_basic_utilities_cancellation_.md)
            *   [Progress](_specification_2024-11-05_basic_utilities_progress_.md)
            
        
    *   [Server Features](_specification_2024-11-05_server_.md)
        
        *   [Prompts](_specification_2024-11-05_server_prompts_.md)
        *   [Resources](_specification_2024-11-05_server_resources_.md)
        *   [Tools](_specification_2024-11-05_server_tools_.md)
        *   [Utilities](_specification_2024-11-05_server_utilities_.md)
            
            *   [Completion](_specification_2024-11-05_server_utilities_completion_.md)
            *   [Logging](_specification_2024-11-05_server_utilities_logging_.md)
            *   [Pagination](_specification_2024-11-05_server_utilities_pagination_.md)
            
        
    *   [Client Features](_specification_2024-11-05_client_.md)
        
        *   [Roots](_specification_2024-11-05_client_roots_.md)
        *   [Sampling](_specification_2024-11-05_client_sampling_.md)
        
    
*   [Versioning](_specification_versioning_.md)
*   [Contributions](_specification_contributing_.md)
*   [Schema ↗](https://github.com/modelcontextprotocol/specification/tree/main/schema)
*   More
*   [User Guide ↗](https://modelcontextprotocol.io)
*   [Python SDK ↗](https://github.com/modelcontextprotocol/python-sdk)
*   [TypeScript SDK ↗](https://github.com/modelcontextprotocol/typescript-sdk)

LightDark

[Specification](_specification_.md)

[2025-03-26 (Latest)](_specification_2025-03-26_.md)

[Server Features](_specification_2025-03-26_server_.md)

Utilities

# Utilities

ℹ️

**Protocol Revision**: 2025-03-26

These optional features can be used to enhance server functionality.

[Completion](_specification_completion.md) [Logging](_specification_logging.md) [Pagination](_specification_pagination.md)

#### _specification_2025-03-26_server_utilities_completion.md

> Source: https://spec.modelcontextprotocol.io/specification/2025-03-26/server/utilities/completion
> Scraped: 4/2/2025, 4:52:14 PM

**Protocol Revision**: 2025-03-26

The Model Context Protocol (MCP) provides a standardized way for servers to offer argument autocompletion suggestions for prompts and resource URIs. This enables rich, IDE-like experiences where users receive contextual suggestions while entering argument values.

## User Interaction Model[](_specification_2025-03-26_server_utilities_completion.md#user-interaction-model)

Completion in MCP is designed to support interactive user experiences similar to IDE code completion.

For example, applications may show completion suggestions in a dropdown or popup menu as users type, with the ability to filter and select from available options.

However, implementations are free to expose completion through any interface pattern that suits their needs—the protocol itself does not mandate any specific user interaction model.

## Capabilities[](_specification_2025-03-26_server_utilities_completion.md#capabilities)

Servers that support completions **MUST** declare the `completions` capability:

## Protocol Messages[](_specification_2025-03-26_server_utilities_completion.md#protocol-messages)

### Requesting Completions[](_specification_2025-03-26_server_utilities_completion.md#requesting-completions)

To get completion suggestions, clients send a `completion/complete` request specifying what is being completed through a reference type:

**Request:***Response:**

### Reference Types[](_specification_2025-03-26_server_utilities_completion.md#reference-types)

The protocol supports two types of completion references:

Type

Description

Example

`ref/prompt`

References a prompt by name

`{"type": "ref/prompt", "name": "code_review"}`

`ref/resource`

References a resource URI

`{"type": "ref/resource", "uri": "file:///{path}"}`

### Completion Results[](_specification_2025-03-26_server_utilities_completion.md#completion-results)

Servers return an array of completion values ranked by relevance, with:
*   Maximum 100 items per response
*   Optional total number of available matches
*   Boolean indicating if additional results exist

## Message Flow[](_specification_2025-03-26_server_utilities_completion.md#message-flow)
```
sequenceDiagram
    participant Client
    participant Server
    Note over Client: User types argument
    Client->>Server: completion/complete
    Server-->>Client: Completion suggestions
    Note over Client: User continues typing
    Client->>Server: completion/complete
    Server-->>Client: Refined suggestions
```
## Data Types[](_specification_2025-03-26_server_utilities_completion.md#data-types)

### CompleteRequest[](_specification_2025-03-26_server_utilities_completion.md#completerequest)
*   `ref`: A `PromptReference` or `ResourceReference`
*   `argument`: Object containing:
    *   `name`: Argument name
    *   `value`: Current value

### CompleteResult[](_specification_2025-03-26_server_utilities_completion.md#completeresult)
*   `completion`: Object containing:
    *   `values`: Array of suggestions (max 100)
    *   `total`: Optional total matches
    *   `hasMore`: Additional results flag

## Error Handling[](_specification_2025-03-26_server_utilities_completion.md#error-handling)

Servers **SHOULD** return standard JSON-RPC errors for common failure cases:
*   Method not found: `-32601` (Capability not supported)
*   Invalid prompt name: `-32602` (Invalid params)
*   Missing required arguments: `-32602` (Invalid params)
*   Internal errors: `-32603` (Internal error)

## Implementation Considerations[](_specification_2025-03-26_server_utilities_completion.md#implementation-considerations)

1.  Servers **SHOULD**:
    
    *   Return suggestions sorted by relevance
    *   Implement fuzzy matching where appropriate
    *   Rate limit completion requests
    *   Validate all inputs
2.  Clients **SHOULD**:
    
    *   Debounce rapid completion requests
    *   Cache completion results where appropriate
    *   Handle missing or partial results gracefully

## Security[](_specification_2025-03-26_server_utilities_completion.md#security)

Implementations **MUST**:
*   Validate all completion inputs
*   Implement appropriate rate limiting
*   Control access to sensitive suggestions
*   Prevent completion-based information disclosure

#### _specification_2025-03-26_server_utilities_logging.md

> Source: https://spec.modelcontextprotocol.io/specification/2025-03-26/server/utilities/logging
> Scraped: 4/2/2025, 4:52:15 PM

**Protocol Revision**: 2025-03-26

The Model Context Protocol (MCP) provides a standardized way for servers to send structured log messages to clients. Clients can control logging verbosity by setting minimum log levels, with servers sending notifications containing severity levels, optional logger names, and arbitrary JSON-serializable data.

## User Interaction Model[](_specification_2025-03-26_server_utilities_logging.md#user-interaction-model)

Implementations are free to expose logging through any interface pattern that suits their needs—the protocol itself does not mandate any specific user interaction model.

## Capabilities[](_specification_2025-03-26_server_utilities_logging.md#capabilities)

Servers that emit log message notifications **MUST** declare the `logging` capability:

## Log Levels[](_specification_2025-03-26_server_utilities_logging.md#log-levels)

The protocol follows the standard syslog severity levels specified in [RFC 5424](https://datatracker.ietf.org/doc/html/rfc5424#section-6.2.1):

Level

Description

Example Use Case

debug

Detailed debugging information

Function entry/exit points

info

General informational messages

Operation progress updates

notice

Normal but significant events

Configuration changes

warning

Warning conditions

Deprecated feature usage

error

Error conditions

Operation failures

critical

Critical conditions

System component failures

alert

Action must be taken immediately

Data corruption detected

emergency

System is unusable

Complete system failure

## Protocol Messages[](_specification_2025-03-26_server_utilities_logging.md#protocol-messages)

### Setting Log Level[](_specification_2025-03-26_server_utilities_logging.md#setting-log-level)

To configure the minimum log level, clients **MAY** send a `logging/setLevel` request:

**Request:**

### Log Message Notifications[](_specification_2025-03-26_server_utilities_logging.md#log-message-notifications)

Servers send log messages using `notifications/message` notifications:

## Message Flow[](_specification_2025-03-26_server_utilities_logging.md#message-flow)
```
sequenceDiagram
    participant Client
    participant Server
    Note over Client,Server: Configure Logging
    Client->>Server: logging/setLevel (info)
    Server-->>Client: Empty Result
    Note over Client,Server: Server Activity
    Server--)Client: notifications/message (info)
    Server--)Client: notifications/message (warning)
    Server--)Client: notifications/message (error)
    Note over Client,Server: Level Change
    Client->>Server: logging/setLevel (error)
    Server-->>Client: Empty Result
    Note over Server: Only sends error level  
and above
```
## Error Handling[](_specification_2025-03-26_server_utilities_logging.md#error-handling)

Servers **SHOULD** return standard JSON-RPC errors for common failure cases:
*   Invalid log level: `-32602` (Invalid params)
*   Configuration errors: `-32603` (Internal error)

## Implementation Considerations[](_specification_2025-03-26_server_utilities_logging.md#implementation-considerations)

1.  Servers **SHOULD**:
    
    *   Rate limit log messages
    *   Include relevant context in data field
    *   Use consistent logger names
    *   Remove sensitive information
2.  Clients **MAY**:
    
    *   Present log messages in the UI
    *   Implement log filtering/search
    *   Display severity visually
    *   Persist log messages

## Security[](_specification_2025-03-26_server_utilities_logging.md#security)

1.  Log messages **MUST NOT** contain:
    
    *   Credentials or secrets
    *   Personal identifying information
    *   Internal system details that could aid attacks
2.  Implementations **SHOULD**:
    
    *   Rate limit messages
    *   Validate all data fields
    *   Control log access
    *   Monitor for sensitive content

#### _specification_2025-03-26_server_utilities_pagination.md

> Source: https://spec.modelcontextprotocol.io/specification/2025-03-26/server/utilities/pagination
> Scraped: 4/2/2025, 4:52:14 PM

**Protocol Revision**: 2025-03-26

The Model Context Protocol (MCP) supports paginating list operations that may return large result sets. Pagination allows servers to yield results in smaller chunks rather than all at once.

Pagination is especially important when connecting to external services over the internet, but also useful for local integrations to avoid performance issues with large data sets.

## Pagination Model[](_specification_2025-03-26_server_utilities_pagination.md#pagination-model)

Pagination in MCP uses an opaque cursor-based approach, instead of numbered pages.
*   The **cursor** is an opaque string token, representing a position in the result set
*   **Page size** is determined by the server, and **MAY NOT** be fixed

## Response Format[](_specification_2025-03-26_server_utilities_pagination.md#response-format)

Pagination starts when the server sends a **response** that includes:
*   The current page of results
*   An optional `nextCursor` field if more results exist

## Request Format[](_specification_2025-03-26_server_utilities_pagination.md#request-format)

After receiving a cursor, the client can _continue_ paginating by issuing a request including that cursor:

## Pagination Flow[](_specification_2025-03-26_server_utilities_pagination.md#pagination-flow)
```
sequenceDiagram
    participant Client
    participant Server
    Client->>Server: List Request (no cursor)
    loop Pagination Loop
      Server-->>Client: Page of results + nextCursor
      Client->>Server: List Request (with cursor)
    end
```
## Operations Supporting Pagination[](_specification_2025-03-26_server_utilities_pagination.md#operations-supporting-pagination)

The following MCP operations support pagination:
*   `resources/list` - List available resources
*   `resources/templates/list` - List resource templates
*   `prompts/list` - List available prompts
*   `tools/list` - List available tools

## Implementation Guidelines[](_specification_2025-03-26_server_utilities_pagination.md#implementation-guidelines)

1.  Servers **SHOULD**:
    
    *   Provide stable cursors
    *   Handle invalid cursors gracefully
2.  Clients **SHOULD**:
    
    *   Treat a missing `nextCursor` as the end of results
    *   Support both paginated and non-paginated flows
3.  Clients **MUST** treat cursors as opaque tokens:
    
    *   Don’t make assumptions about cursor format
    *   Don’t attempt to parse or modify cursors
    *   Don’t persist cursors across sessions

## Error Handling[](_specification_2025-03-26_server_utilities_pagination.md#error-handling)

Invalid cursors **SHOULD** result in an error with code -32602 (Invalid params).

